<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MicroPython Web IDE</title>
    <!-- Monaco Editor -->
    <link rel="stylesheet" data-name="vs/editor/editor.main" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/editor/editor.main.min.css">
    <script>
        var require = { paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs' } };
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/loader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/editor/editor.main.nls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/editor/editor.main.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            background: #2d2d30;
            padding: 10px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .btn {
            background: #0e639c;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #1177bb;
        }

        .btn:disabled {
            background: #555;
            cursor: not-allowed;
        }

        .btn.danger {
            background: #d73a49;
        }

        .btn.danger:hover {
            background: #e85565;
        }

        .status {
            margin-left: auto;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .status.connected {
            background: #28a745;
        }

        .status.disconnected {
            background: #dc3545;
        }

        .main-content {
            display: flex;
            flex: 1;
            min-height: 0;
        }

        .editor-panel {
            flex: 1; /* Nimmt verf√ºgbaren Platz ein */
            display: flex;
            flex-direction: column;
            min-width: 200px; /* Mindestbreite f√ºr den Editor */
        }

        #resizerVertical {
            width: 5px;
            background-color: #3e3e42;
            cursor: col-resize;
            flex-shrink: 0; /* Verhindert, dass der Resizer schrumpft */
        }

        .file-tabs {
            background: #2d2d30;
            padding: 0;
            border-bottom: 1px solid #3e3e42;
            display: flex;
        }

        .tab {
            background: #3c3c3c;
            border: none;
            color: #d4d4d4;
            padding: 8px 16px;
            cursor: pointer;
            border-right: 1px solid #3e3e42;
            font-size: 12px;
        }

        .tab.active {
            background: #1e1e1e;
        }

        #editor-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .terminal-panel {
            /* width: 40%; wird durch flex-basis ersetzt */
            flex: 0 0 40%; /* Nicht wachsen, nicht schrumpfen, Basisbreite 40% */
            display: flex;
            flex-direction: column;
            min-width: 150px; /* Mindestbreite f√ºr das Terminal */
            background: #0c0c0c;
        }

        .terminal-header {
            background: #2d2d30;
            padding: 8px 12px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .terminal {
            flex: 1;
            background: #0c0c0c;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .terminal-input {
            background: #0c0c0c;
            border: none;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            outline: none;
            border-top: 1px solid #3e3e42;
        }

        .file-browser {
            width: 200px;
            flex-shrink: 0; /* Verhindert, dass der File-Browser schrumpft */
            background: #252526;
            border-right: 1px solid #3e3e42;
            padding: 10px;
            overflow-y: auto;
        }

        .file-item {
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
        }

        .file-item:hover {
            background: #2a2d2e;
        }

        .file-item.selected {
            background: #094771;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .modal-content {
            background: #2d2d30;
            margin: 15% auto;
            padding: 20px;
            border-radius: 8px;
            width: 300px;
            color: #d4d4d4;
        }

        .modal input {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            color: #d4d4d4;
            border-radius: 4px;
        }

        .spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #555;
            border-top: 2px solid #0e639c;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .prompt-panel {
            display: flex;
            padding: 10px;
            background: #2d2d30;
            border-top: 1px solid #3e3e42;
        }

        .prompt-panel input {
            flex-grow: 1;
            padding: 8px;
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            color: #d4d4d4;
            border-radius: 4px;
            font-size: 12px;
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <button class="btn" id="connectBtn">Mit ESP32 verbinden</button>
        <button class="btn" id="runBtn" disabled>Ausf√ºhren (F5)</button>
        <button class="btn" id="stopBtn" disabled>Stopp</button>
        <button class="btn" id="uploadBtn" disabled>Hochladen</button>
        <button class="btn" id="listFilesBtn" disabled>Dateien auflisten</button>
        <button class="btn danger" id="softResetBtn" disabled>Soft Reset</button>
        <input type="password" id="deepSeekApiKeyInput" placeholder="DeepSeek API Key" style="margin-left: 10px; padding: 8px; background: #1e1e1e; border: 1px solid #3e3e42; color: #d4d4d4; border-radius: 4px; font-size: 12px; min-width: 200px;">
        <div class="status disconnected" id="status">Nicht verbunden</div>
    </div>

    <div class="main-content">
        <div class="file-browser">
            <h4 style="margin-bottom: 10px;">Dateien auf ESP32</h4>
            <div id="fileList"></div>
        </div>

        <div class="editor-panel" id="editorPanel">
            <div class="file-tabs">
                <button class="tab active" data-file="main.py">main.py</button>
            </div>
            <div id="editor-container">
                <div id="editor" style="height:100%"></div>
            </div>
            <div class="prompt-panel">
                <input type="text" id="llmPromptInput" placeholder="Prompt f√ºr DeepSeek eingeben...">
                <button class="btn" id="sendToLlmBtn">An DeepSeek senden</button>
                <button class="btn" id="acceptLlmChangesBtn" style="display: none; margin-left: 10px;">√Ñnderungen √ºbernehmen</button>
                <button class="btn danger" id="rejectLlmChangesBtn" style="display: none; margin-left: 10px;">Ablehnen</button>
            </div>
        </div>

        <div id="resizerVertical"></div>

        <div class="terminal-panel" id="terminalPanel">
            <div class="terminal-header">
                <span>REPL Terminal</span>
                <button class="btn" id="clearTerminalBtn">L√∂schen</button>
            </div>
            <div class="terminal" id="terminal">Bereit f√ºr Verbindung...\n</div>
            <input class="terminal-input" id="terminalInput" placeholder=">>> MicroPython Befehl eingeben..." disabled>
        </div>
    </div>

    <!-- Modal f√ºr Dateinamen -->
    <div class="modal" id="filenameModal">
        <div class="modal-content">
            <h3>Datei speichern als:</h3>
            <input type="text" id="filenameInput" placeholder="dateiname.py">
            <div id="uploadProgressBarContainer" style="margin-top: 10px; background-color: #1e1e1e; border-radius: 4px; display: none;">
                <div id="uploadProgressBar" style="width: 0%; height: 10px; background-color: #0e639c; border-radius: 4px; text-align: center; line-height: 10px; font-size: 8px; color: white;"></div>
            </div>
            <div style="margin-top: 15px;">
                <button class="btn" id="saveFileBtn">Speichern</button>
                <button class="btn" onclick="closeModal()">Abbrechen</button>
            </div>
        </div>
    </div>

    <script>
        class MicroPythonIDE {
            constructor(editor) {
                this.port = null;
                this.reader = null;
                this.writer = null;
                this.isConnected = false;
                this.currentFile = 'main.py';
                this.editor = editor;
                this.files = {'main.py': this.editor.getValue()};
                this.deepSeekApiKey = localStorage.getItem('deepSeekApiKey') || '';
                this.diffEditor = null;
                this.diffEditorContainerDiv = null;
                this.originalEditorDiv = document.getElementById('editor');
                this.editorContainerDiv = document.getElementById('editor-container');
                
                this.initializeEventListeners();
                this.checkWebSerialSupport();
                document.getElementById('deepSeekApiKeyInput').value = this.deepSeekApiKey;
            }

            checkWebSerialSupport() {
                if (!('serial' in navigator)) {
                    this.addToTerminal('‚ùå Web Serial API wird nicht unterst√ºtzt. Bitte verwende Chrome oder Edge.\n');
                }
            }

            initializeEventListeners() {
                document.getElementById('connectBtn').addEventListener('click', () => this.toggleConnection());
                document.getElementById('runBtn').addEventListener('click', () => this.runCode());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopExecution());
                document.getElementById('uploadBtn').addEventListener('click', () => this.showUploadModal());
                document.getElementById('listFilesBtn').addEventListener('click', () => this.listFiles());
                document.getElementById('softResetBtn').addEventListener('click', () => this.softReset());
                document.getElementById('clearTerminalBtn').addEventListener('click', () => this.clearTerminal());
                document.getElementById('terminalInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendCommand();
                });
                document.getElementById('saveFileBtn').addEventListener('click', () => this.uploadFile());

                // F5 f√ºr Ausf√ºhren
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'F5') {
                        e.preventDefault();
                        if (this.isConnected) this.runCode();
                    }
                });

                // Editor √Ñnderungen speichern
                this.editor.onDidChangeModelContent(() => {
                    this.files[this.currentFile] = this.editor.getValue();
                });

                document.getElementById('deepSeekApiKeyInput').addEventListener('input', (e) => {
                    this.deepSeekApiKey = e.target.value;
                    localStorage.setItem('deepSeekApiKey', this.deepSeekApiKey);
                });

                document.getElementById('sendToLlmBtn').addEventListener('click', () => this.callDeepSeekApi());
                document.getElementById('acceptLlmChangesBtn').addEventListener('click', () => this.acceptLLMChanges());
                document.getElementById('rejectLlmChangesBtn').addEventListener('click', () => this.rejectLLMChanges());

                this.initializeResizer();
            }

            initializeResizer() {
                const resizer = document.getElementById('resizerVertical');
                const editorPanel = document.getElementById('editorPanel');
                const terminalPanel = document.getElementById('terminalPanel');
                const fileBrowser = document.querySelector('.file-browser');

                let initialX = 0;
                let initialTerminalWidth = 0;

                const onMouseMove = (e) => {
                    const dx = e.clientX - initialX;
                    let newTerminalWidth = initialTerminalWidth - dx;

                    const mainContentWidth = resizer.parentElement.offsetWidth;
                    const fileBrowserWidth = fileBrowser.offsetWidth;
                    const resizerWidth = resizer.offsetWidth;
                    
                    const minPanelPixelWidth = 150; // Mindestbreite f√ºr Editor und Terminal in Pixeln

                    const maxTerminalWidth = mainContentWidth - fileBrowserWidth - resizerWidth - minPanelPixelWidth;
                    
                    if (newTerminalWidth < minPanelPixelWidth) {
                        newTerminalWidth = minPanelPixelWidth;
                    }
                    if (newTerminalWidth > maxTerminalWidth) {
                        newTerminalWidth = maxTerminalWidth;
                    }
                    
                    const currentEditorWidth = mainContentWidth - fileBrowserWidth - resizerWidth - newTerminalWidth;
                    if (currentEditorWidth < minPanelPixelWidth) {
                        newTerminalWidth = mainContentWidth - fileBrowserWidth - resizerWidth - minPanelPixelWidth;
                        if (newTerminalWidth < minPanelPixelWidth) newTerminalWidth = minPanelPixelWidth; // Erneut pr√ºfen
                    }

                    terminalPanel.style.flexBasis = `${newTerminalWidth}px`;

                    if (this.editor && typeof this.editor.layout === 'function') {
                        this.editor.layout();
                    }
                };

                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    document.body.style.cursor = 'default';
                    document.body.style.userSelect = 'auto';
                };

                resizer.addEventListener('mousedown', (e) => {
                    e.preventDefault(); // Verhindert Textauswahl w√§hrend des Ziehens
                    initialX = e.clientX;
                    initialTerminalWidth = terminalPanel.offsetWidth;

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                    document.body.style.cursor = 'col-resize'; // Zeigt den Cursor global an
                    document.body.style.userSelect = 'none'; // Verhindert Textauswahl global
                });
            }

            async callDeepSeekApi() {
                const prompt = document.getElementById('llmPromptInput').value;
                const originalCode = this.editor.getValue(); // Originalcode speichern

                if (!this.deepSeekApiKey) {
                    this.addToTerminal('\n‚ùå Bitte zuerst einen DeepSeek API Key eingeben.\n');
                    console.error('DeepSeek API Key fehlt.');
                    alert('Bitte zuerst einen DeepSeek API Key im Feld oben rechts eingeben.');
                    return;
                }

                if (!prompt) {
                    this.addToTerminal('\n‚ÑπÔ∏è Bitte einen Prompt f√ºr DeepSeek eingeben.\n');
                    alert('Bitte einen Prompt f√ºr DeepSeek eingeben.');
                    return;
                }

                this.addToTerminal('\nü§ñ Sende Anfrage an DeepSeek...\n');
                const sendToLlmBtn = document.getElementById('sendToLlmBtn');
                sendToLlmBtn.disabled = true;
                sendToLlmBtn.innerHTML = '<span class="spinner"></span> Sende...';

                const API_URL = `https://api.deepseek.com/chat/completions`;
                const systemPrompt = "You are a helpful assistant that generates MicroPython code for microcontrollers. Ensure the code is valid MicroPython and directly usable on devices like ESP32. Only output the Python code, without any surrounding text or explanations unless explicitly asked.";

                const requestBody = {
                    model: "deepseek-chat",
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: `${prompt}\n\nAktueller Code im Editor (falls vorhanden, ansonsten generiere neuen Code):\n\`\`\`python\n${currentCode}\n\`\`\`` }
                    ],
                    temperature: 0.7,
                    // max_tokens: 2048, // Kann bei Bedarf angepasst werden
                };

                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.deepSeekApiKey}`
                        },
                        body: JSON.stringify(requestBody),
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error('DeepSeek API Error Response:', errorData);
                        this.addToTerminal(`\n‚ùå Fehler von DeepSeek API: ${response.status} ${response.statusText}\nDetails: ${JSON.stringify(errorData.error?.message || errorData)}\n`);
                        throw new Error(`API request failed with status ${response.status}: ${JSON.stringify(errorData)}`);
                    }

                    const data = await response.json();
                    console.log('DeepSeek API Success Response:', data);

                    if (data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
                        let llmOutput = data.choices[0].message.content;
                        
                        // Versuche, reinen Code aus Markdown-Codebl√∂cken zu extrahieren
                        const codeBlockMatch = llmOutput.match(/```python\n([\s\S]*?)\n```|```([\s\S]*?)\n```/);
                        let newCode = llmOutput; 

                        if (codeBlockMatch) {
                            newCode = codeBlockMatch[1] || codeBlockMatch[2]; 
                            const textBefore = llmOutput.substring(0, codeBlockMatch.index).trim();
                            const textAfter = llmOutput.substring(codeBlockMatch.index + codeBlockMatch[0].length).trim();
                            if (textBefore) console.log("LLM Info (vor Codeblock):", textBefore);
                            if (textAfter) console.log("LLM Info (nach Codeblock):", textAfter);
                        } else {
                             // Wenn kein expliziter Codeblock, aber die Ausgabe mit "python" beginnt (manchmal bei DeepSeek)
                             if (llmOutput.toLowerCase().startsWith("python\n")) {
                                 newCode = llmOutput.substring("python\n".length);
                             }
                             console.log("LLM Info (kein expliziter Python-Codeblock gefunden, verwende angepasste/gesamte Ausgabe als Code):", llmOutput);
                        }
                        
                        // Entferne m√∂gliche einleitende/abschlie√üende Leerzeilen, die vom LLM kommen k√∂nnten
                        newCode = newCode.trim();

                        // Diff-Ansicht anzeigen, anstatt den Editor direkt zu aktualisieren
                        this.showDiff(originalCode, newCode);
                        this.addToTerminal('\n‚úÖ Code vom LLM erhalten. Bitte √ºberpr√ºfen Sie die √Ñnderungen.\n');
                        // document.getElementById('llmPromptInput').value = ''; // Wird jetzt in hideDiffAndRestoreEditor gemacht
                    } else {
                        console.warn('DeepSeek API: Keine g√ºltigen Kandidaten in der Antwort gefunden.', data);
                        this.addToTerminal('\n‚ö†Ô∏è DeepSeek hat keinen Code oder eine unerwartete Antwortstruktur zur√ºckgegeben.\n');
                    }

                } catch (error) {
                    console.error('Fehler bei der Anfrage an DeepSeek API:', error);
                    this.addToTerminal(`\n‚ùå Fehler bei der Kommunikation mit DeepSeek: ${error.message}\n`);
                } finally {
                    sendToLlmBtn.disabled = false;
                    sendToLlmBtn.innerHTML = 'An DeepSeek senden';
                }
            }

            async toggleConnection() {
                if (this.isConnected) {
                    await this.disconnect();
                } else {
                    await this.connect();
                }
            }

            async connect() {
                try {
                    this.addToTerminal('üîå Verbinde mit ESP32...\n');
                    
                    this.port = await navigator.serial.requestPort();
                    await this.port.open({ baudRate: 115200 });

                    this.reader = this.port.readable.getReader();
                    this.writer = this.port.writable.getWriter();

                    this.isConnected = true;
                    this.updateUI();
                    
                    this.addToTerminal('‚úÖ Erfolgreich verbunden!\n');
                    
                    // REPL starten
                    await this.sendRawCommand('\x03\x03\x02'); // Ctrl+C, Ctrl+C, Ctrl+B
                    
                    this.startReading();
                    
                } catch (error) {
                    this.addToTerminal(`‚ùå Verbindungsfehler: ${error.message}\n`);
                }
            }

            async disconnect() {
                try {
                    if (this.reader) {
                        await this.reader.cancel();
                        this.reader.releaseLock();
                    }
                    if (this.writer) {
                        this.writer.releaseLock();
                    }
                    if (this.port) {
                        await this.port.close();
                    }
                    
                    this.isConnected = false;
                    this.updateUI();
                    this.addToTerminal('üîå Verbindung getrennt\n');
                    
                } catch (error) {
                    this.addToTerminal(`‚ùå Fehler beim Trennen: ${error.message}\n`);
                }
            }

            async startReading() {
                try {
                    let buffer = '';
                    while (this.isConnected) {
                        const { value, done } = await this.reader.read();
                        if (done) break;
                        
                        const text = new TextDecoder().decode(value);
                        this.addToTerminal(text);
                        
                        // Check for file list output
                        buffer += text;
                        if (buffer.includes('===FILELIST_END===')) {
                            const files = this.parseFileList(buffer);
                            if (files) {
                                this.updateFileBrowser(files);
                            }
                            buffer = '';
                        }
                        
                        // Check for file content output
                        if (buffer.includes('===FILE_CONTENT_END===')) {
                            const content = this.parseFileContent(buffer);
                            if (content) {
                                this.editor.setValue(content);
                                this.files[this.currentFile] = content;
                            }
                            buffer = '';
                        }
                    }
                } catch (error) {
                    if (this.isConnected) {
                        this.addToTerminal(`‚ùå Lesefehler: ${error.message}\n`);
                    }
                }
            }

            async sendRawCommand(command) {
                if (!this.writer) return;
                
                const encoder = new TextEncoder();
                await this.writer.write(encoder.encode(command));
            }

            async sendCommand() {
                const input = document.getElementById('terminalInput');
                const command = input.value;
                
                if (!command.trim()) return;
                
                this.addToTerminal(`>>> ${command}\n`);
                await this.sendRawCommand(command + '\r\n');
                
                input.value = '';
            }

            async runCode() {
                if (!this.isConnected) return;
                
                if (!this.currentFile) {
                    this.addToTerminal('\n‚ùå Bitte erst eine Datei hochladen\n');
                    return;
                }
                
                this.addToTerminal(`\n=== F√ºhre ${this.currentFile} aus ===\n`);
                
                // Code ausf√ºhren mittels Paste-Modus und exec
                await this.sendRawCommand('\r\n'); // Sicherstellen, dass die REPL-Zeile frei ist
                await new Promise(resolve => setTimeout(resolve, 50));

                // Construct the script with \r line endings for paste mode

                const pythonScriptSource = `try:
    with open('${this.currentFile}', 'r') as f:
        exec(f.read())
except OSError:
    print("Error: ${this.currentFile} not found")
except SyntaxError as e:
    print(f"SyntaxError in ${this.currentFile}: {e}")
`;
                const pythonScript = pythonScriptSource.replace(/\n/g, '\r') + '\r';                

                await this.sendRawCommand('\x05'); // Ctrl-E: Paste-Modus starten
                await new Promise(resolve => setTimeout(resolve, 100)); // Kurze Pause
                
                await this.sendRawCommand(pythonScript);
                // Keine zus√§tzliche Pause hier, da der gesamte Block auf einmal gesendet wird
                
                await this.sendRawCommand('\x04'); // Ctrl-D: Paste-Modus beenden und ausf√ºhren
                await new Promise(resolve => setTimeout(resolve, 100)); // Kurze Pause danach
            }

            async stopExecution() {
                if (!this.isConnected) return;
                
                this.addToTerminal('\nüõë Stoppe Ausf√ºhrung...\n');
                await this.sendRawCommand('\x03'); // Ctrl+C
            }

            async softReset() {
                if (!this.isConnected) return;
                
                this.addToTerminal('\nüîÑ Soft Reset...\n');
                await this.sendRawCommand('\x04'); // Ctrl+D
            }

            showUploadModal() {
                document.getElementById('filenameModal').style.display = 'block';
                document.getElementById('filenameInput').value = this.currentFile;
                document.getElementById('filenameInput').focus();
                // Fortschrittsbalken zur√ºcksetzen und ausblenden
                const progressBarContainer = document.getElementById('uploadProgressBarContainer');
                const progressBar = document.getElementById('uploadProgressBar');
                progressBar.style.width = '0%';
                progressBar.textContent = '';
                progressBarContainer.style.display = 'none';
            }

            async uploadFile() {
                const filename = document.getElementById('filenameInput').value;
                if (!filename) return;
                if (!filename.endsWith('.py')) {
                    this.addToTerminal('\n‚ùå Dateiname muss mit .py enden\n');
                    return;
                }
                
                const code = this.editor.getValue();
                this.currentFile = filename;
                const chunkSize = 200; // Noch kleinere Chunk-Gr√∂√üe
                const totalChunks = Math.ceil(code.length / chunkSize);

                const progressBarContainer = document.getElementById('uploadProgressBarContainer');
                const progressBar = document.getElementById('uploadProgressBar');
                progressBar.style.width = '0%';
                progressBar.textContent = '0%';
                progressBarContainer.style.display = 'block';
                
                this.addToTerminal(`\nüì§ Lade ${filename} hoch (${code.length} Zeichen, ${totalChunks} Teile)...\n`);
                this.addToTerminal('‚ö†Ô∏è Bitte warten w√§hrend die Datei hochgeladen wird...\n');
                
                try {
                    // Datei erstellen
                    await this.sendRawCommand('\x05');
                    await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                    await this.sendRawCommand(`f=open('${filename}','w')\r\n`);
                    await this.sendRawCommand('\x04');
                    await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                    
                    // Code in Chunks hochladen
                    for (let i = 0; i < totalChunks; i++) {
                        const chunk = code.substring(i * chunkSize, (i + 1) * chunkSize);
                        // Sonderzeichen escapen
                        const escapedChunk = chunk
                            .replace(/\\/g, '\\\\')
                            .replace(/'/g, "\\'")
                            .replace(/\r/g, '\\r')
                            .replace(/\n/g, '\\n');
                        
                        try {
                            await this.sendRawCommand('\x05');
                            await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                            await this.sendRawCommand(`f.write('${escapedChunk}')\r\n`);
                            await this.sendRawCommand('\x04');
                            await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                            
                            // Fortschritt anzeigen
                            const progress = Math.round(((i + 1) / totalChunks) * 100);
                            this.addToTerminal(`\rüîº Hochgeladen: ${progress}% (${(i + 1) * chunkSize}/${code.length})`);
                            progressBar.style.width = progress + '%';
                            progressBar.textContent = progress + '%';
                        } catch (error) {
                            this.addToTerminal(`\n‚ùå Fehler bei Chunk ${i+1}: ${error.message}\n`);
                            progressBarContainer.style.display = 'none'; // Fortschrittsbalken bei Fehler ausblenden
                            throw error;
                        }
                    }
                    
                    // Datei schlie√üen
                    await this.sendRawCommand('\x05');
                    await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                    await this.sendRawCommand('f.close()\r\n');
                    await this.sendRawCommand('\x04');
                    await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                    
                    this.addToTerminal(`\n‚úÖ ${filename} erfolgreich hochgeladen!\n`);
                    progressBar.textContent = '100%'; // Sicherstellen, dass es 100% anzeigt
                    
                } catch (error) {
                    this.addToTerminal(`\n‚ùå Fehler beim Hochladen: ${error.message}\n`);
                    progressBarContainer.style.display = 'none'; // Fortschrittsbalken bei Fehler ausblenden
                } finally {
                    // Kurze Verz√∂gerung, bevor das Modal geschlossen wird, damit der Benutzer 100% sieht
                    setTimeout(() => {
                        closeModal();
                        // Fortschrittsbalken f√ºr das n√§chste Mal ausblenden (wird auch in showUploadModal gemacht, aber sicher ist sicher)
                        progressBarContainer.style.display = 'none';
                        progressBar.style.width = '0%';
                        progressBar.textContent = '';
                    }, 500);
                    setTimeout(() => this.listFiles(), 1000); // listFiles nach dem Schlie√üen des Modals
                }
            }

            async loadFile(filename) {
                if (!this.isConnected) return;
                
                this.addToTerminal(`\nüì• Lade ${filename}...\n`);
                
                const loadCode = `
try:
    with open('${filename}', 'r') as f:
        print('===FILE_CONTENT_START===')
        print(f.read())
        print('===FILE_CONTENT_END===')
except Exception as e:
    print('Fehler:', e)
`;
                
                await this.sendRawCommand('\x05');
                await new Promise(resolve => setTimeout(resolve, 100));
                await this.sendRawCommand(loadCode);
                await this.sendRawCommand('\x04');
                
                // Datei im Editor anzeigen
                this.currentFile = filename;
                this.editor.setValue('');
            }

            parseFileContent(text) {
                const startMarker = '===FILE_CONTENT_START===';
                const endMarker = '===FILE_CONTENT_END===';
                
                const start = text.indexOf(startMarker);
                const end = text.indexOf(endMarker);
                
                if (start === -1 || end === -1) return null;
                
                let content = text.substring(start + startMarker.length, end);
                // Normalisiere Zeilenenden (CRLF -> LF)
                content = content.replace(/\r\n/g, '\n');
                // Entferne √ºberfl√ºssige Leerzeilen am Anfang und Ende
                content = content.replace(/^\n+|\n+$/g, '');
                return content;
            }

            async listFiles() {
                if (!this.isConnected) return;
                
                this.addToTerminal('\nüìÅ Dateien werden aufgelistet...\n');
                
                const listCode = `
import os
print('===FILELIST_START===')
for file in os.listdir():
    try:
        stat = os.stat(file)
        size = stat[6]
        print(f'{file}|{size}')
    except:
        print(f'{file}|folder')
print('===FILELIST_END===')
`;
                
                await this.sendRawCommand('\x05');
                await new Promise(resolve => setTimeout(resolve, 100));
                await this.sendRawCommand(listCode);
                await this.sendRawCommand('\x04');
            }

            parseFileList(text) {
                const startMarker = '===FILELIST_START===';
                const endMarker = '===FILELIST_END===';
                
                const start = text.indexOf(startMarker);
                const end = text.indexOf(endMarker);
                
                if (start === -1 || end === -1) return null;
                
                const fileListText = text.substring(start + startMarker.length, end).trim();
                const lines = fileListText.split('\n');
                
                const files = [];
                for (const line of lines) {
                    const [name, size] = line.split('|');
                    files.push({name, size});
                }
                
                return files;
            }

            updateFileBrowser(files) {
                const fileListElement = document.getElementById('fileList');
                fileListElement.innerHTML = '';
                
                files.forEach(file => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.textContent = `${file.name} (${file.size === 'folder' ? 'Ordner' : file.size + ' bytes'})`;
                    fileItem.addEventListener('click', () => this.loadFile(file.name));
                    fileListElement.appendChild(fileItem);
                });
            }

            addToTerminal(text) {
                const terminal = document.getElementById('terminal');
                terminal.textContent += text;
                terminal.scrollTop = terminal.scrollHeight;
            }

            clearTerminal() {
                document.getElementById('terminal').textContent = '';
            }

            updateUI() {
                const connectBtn = document.getElementById('connectBtn');
                const status = document.getElementById('status');
                const buttons = ['runBtn', 'stopBtn', 'uploadBtn', 'listFilesBtn', 'softResetBtn'];
                const terminalInput = document.getElementById('terminalInput');
                
                if (this.isConnected) {
                    connectBtn.textContent = 'Trennen';
                    status.textContent = 'Verbunden';
                    status.className = 'status connected';
                    buttons.forEach(id => document.getElementById(id).disabled = false);
                    terminalInput.disabled = false;
                } else {
                    connectBtn.textContent = 'Mit ESP32 verbinden';
                    status.textContent = 'Nicht verbunden';
                    status.className = 'status disconnected';
                    buttons.forEach(id => document.getElementById(id).disabled = true);
                    terminalInput.disabled = true;
                }
            }
        }

        function closeModal() {
            document.getElementById('filenameModal').style.display = 'none';
        }

        // Monaco Editor initialisieren
        function initEditor() {
            try {
                require(['vs/editor/editor.main'], function() {
                    const editor = monaco.editor.create(document.getElementById('editor'), {
                        value: [
                            "# Dein MicroPython Code hier...",
                            "print('Hello ESP32!')",
                            "",
                            "# Beispiel: LED blinken",
                            "from machine import Pin",
                            "import time",
                            "",
                            "led = Pin(2, Pin.OUT)  # GPIO 2 f√ºr eingebaute LED",
                            "",
                            "for i in range(10):",
                            "    led.on()",
                            "    time.sleep(0.5)",
                            "    led.off()",
                            "    time.sleep(0.5)",
                            "    print('Blink ' + str(i + 1))  # f-string removed for wider compatibility"
                        ].join('\n'),
                        language: 'python',
                        theme: 'vs-dark',
                        automaticLayout: true,
                        minimap: { enabled: false },
                        fontSize: 14,
                        lineNumbers: 'on',
                        roundedSelection: true,
                        scrollBeyondLastLine: false,
                        renderWhitespace: 'selection',
                        tabSize: 4
                    });

                    // IDE initialisieren und Editor √ºbergeben
                    window.ide = new MicroPythonIDE(editor);
                });
            } catch (error) {
                console.error('Editor Initialization Error:', error);
                // Fallback falls Monaco nicht l√§dt
                const editorElement = document.getElementById('editor');
                editorElement.innerHTML = '<textarea style="width:100%;height:100%;background:#1e1e1e;color:#d4d4d4;border:none;padding:10px;font-family:monospace;font-size:14px;" id="fallbackEditor"># Dein MicroPython Code hier...\nprint(\'Hello ESP32!\')</textarea>';
                window.ide = new MicroPythonIDE({
                    getValue: () => document.getElementById('fallbackEditor').value,
                    setValue: (content) => document.getElementById('fallbackEditor').value = content,
                    onDidChangeModelContent: (callback) => {
                        document.getElementById('fallbackEditor').addEventListener('input', callback);
                    }
                });
            }
        }

        // Editor laden wenn alles fertig ist
        if (document.readyState === 'complete') {
            initEditor();
        } else {
            window.addEventListener('load', initEditor);
        }
    </script>
</body>
</html>
