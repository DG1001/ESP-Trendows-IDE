<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MicroPython Web IDE</title>
    <!-- Monaco Editor -->
    <link rel="stylesheet" data-name="vs/editor/editor.main" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/editor/editor.main.min.css">
    <script>
        var require = { paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs' } };
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/loader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/editor/editor.main.nls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/editor/editor.main.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            background: #2d2d30;
            padding: 10px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .btn {
            background: #0e639c;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #1177bb;
        }

        .btn:disabled {
            background: #555;
            cursor: not-allowed;
        }

        .btn.danger {
            background: #d73a49;
        }

        .btn.danger:hover {
            background: #e85565;
        }

        .status {
            margin-left: auto;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .status.connected {
            background: #28a745;
        }

        .status.disconnected {
            background: #dc3545;
        }

        .main-content {
            display: flex;
            flex: 1;
            min-height: 0;
        }

        .editor-panel {
            flex: 1; /* Nimmt verfügbaren Platz ein */
            display: flex;
            flex-direction: column;
            min-width: 200px; /* Mindestbreite für den Editor */
        }

        #resizerVertical {
            width: 5px;
            background-color: #3e3e42;
            cursor: col-resize;
            flex-shrink: 0; /* Verhindert, dass der Resizer schrumpft */
        }

        .file-tabs {
            background: #2d2d30;
            padding: 0;
            border-bottom: 1px solid #3e3e42;
            display: flex;
        }

        .tab {
            background: #3c3c3c;
            border: none;
            color: #d4d4d4;
            padding: 8px 16px;
            cursor: pointer;
            border-right: 1px solid #3e3e42;
            font-size: 12px;
        }

        .tab.active {
            background: #1e1e1e;
        }

        #editor-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .terminal-panel {
            /* width: 40%; wird durch flex-basis ersetzt */
            flex: 0 0 40%; /* Nicht wachsen, nicht schrumpfen, Basisbreite 40% */
            display: flex;
            flex-direction: column;
            min-width: 150px; /* Mindestbreite für das Terminal */
            background: #0c0c0c;
        }

        .terminal-header {
            background: #2d2d30;
            padding: 8px 12px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .terminal {
            flex: 1;
            background: #0c0c0c;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .terminal-input {
            background: #0c0c0c;
            border: none;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            outline: none;
            border-top: 1px solid #3e3e42;
        }

        .file-browser {
            width: 200px;
            flex-shrink: 0; /* Verhindert, dass der File-Browser schrumpft */
            background: #252526;
            border-right: 1px solid #3e3e42;
            padding: 10px;
            overflow-y: auto;
        }

        .file-item {
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
        }

        .file-item:hover {
            background: #2a2d2e;
        }

        .file-item.selected {
            background: #094771;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .modal-content {
            background: #2d2d30;
            margin: 15% auto;
            padding: 20px;
            border-radius: 8px;
            width: 300px;
            color: #d4d4d4;
        }

        .modal input {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            color: #d4d4d4;
            border-radius: 4px;
        }

        .spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #555;
            border-top: 2px solid #0e639c;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .prompt-panel {
            display: flex;
            padding: 10px;
            background: #2d2d30;
            border-top: 1px solid #3e3e42;
        }

        .prompt-panel input {
            flex-grow: 1;
            padding: 8px;
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            color: #d4d4d4;
            border-radius: 4px;
            font-size: 12px;
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <button class="btn" id="connectBtn">Mit ESP32 verbinden</button>
        <button class="btn" id="runBtn" disabled>Ausführen (F5)</button>
        <button class="btn" id="stopBtn" disabled>Stopp</button>
        <button class="btn" id="uploadBtn" disabled>Hochladen</button>
        <button class="btn" id="listFilesBtn" disabled>Dateien auflisten</button>
        <button class="btn danger" id="softResetBtn" disabled>Soft Reset</button>
        <input type="password" id="deepSeekApiKeyInput" placeholder="DeepSeek API Key" style="margin-left: 10px; padding: 8px; background: #1e1e1e; border: 1px solid #3e3e42; color: #d4d4d4; border-radius: 4px; font-size: 12px; min-width: 200px;">
        <div class="status disconnected" id="status">Nicht verbunden</div>
    </div>

    <div class="main-content">
        <div class="file-browser">
            <h4 style="margin-bottom: 10px;">Dateien auf ESP32</h4>
            <div id="fileList"></div>
        </div>

        <div class="editor-panel" id="editorPanel">
            <div class="file-tabs">
                <button class="tab active" data-file="main.py">main.py</button>
            </div>
            <div id="editor-container">
                <div id="editor" style="height:100%"></div>
            </div>
            <div class="prompt-panel">
                <input type="text" id="llmPromptInput" placeholder="Prompt für DeepSeek eingeben...">
                <button class="btn" id="sendToLlmBtn">An DeepSeek senden</button>
                <button class="btn" id="acceptLlmChangesBtn" style="display: none; margin-left: 10px;">Änderungen übernehmen</button>
                <button class="btn danger" id="rejectLlmChangesBtn" style="display: none; margin-left: 10px;">Ablehnen</button>
            </div>
        </div>

        <div id="resizerVertical"></div>

        <div class="terminal-panel" id="terminalPanel">
            <div class="terminal-header">
                <span>REPL Terminal</span>
                <button class="btn" id="clearTerminalBtn">Löschen</button>
            </div>
            <div class="terminal" id="terminal">Bereit für Verbindung...\n</div>
            <input class="terminal-input" id="terminalInput" placeholder=">>> MicroPython Befehl eingeben..." disabled>
        </div>
    </div>

    <!-- Modal für Dateinamen -->
    <div class="modal" id="filenameModal">
        <div class="modal-content">
            <h3>Datei speichern als:</h3>
            <input type="text" id="filenameInput" placeholder="dateiname.py">
            <div id="uploadProgressBarContainer" style="margin-top: 10px; background-color: #1e1e1e; border-radius: 4px; display: none;">
                <div id="uploadProgressBar" style="width: 0%; height: 10px; background-color: #0e639c; border-radius: 4px; text-align: center; line-height: 10px; font-size: 8px; color: white;"></div>
            </div>
            <div style="margin-top: 15px;">
                <button class="btn" id="saveFileBtn">Speichern</button>
                <button class="btn" onclick="closeModal()">Abbrechen</button>
            </div>
        </div>
    </div>

    <script>
        class MicroPythonIDE {
            constructor(editor) {
                this.port = null;
                this.reader = null;
                this.writer = null;
                this.isConnected = false;
                this.currentFile = 'main.py';
                this.editor = editor;
                this.files = {'main.py': this.editor.getValue()};
                this.deepSeekApiKey = localStorage.getItem('deepSeekApiKey') || '';
                this.diffEditor = null;
                this.diffEditorContainerDiv = null;
                this.originalEditorDiv = document.getElementById('editor');
                this.editorContainerDiv = document.getElementById('editor-container');
                
                this.initializeEventListeners();
                this.checkWebSerialSupport();
                document.getElementById('deepSeekApiKeyInput').value = this.deepSeekApiKey;
            }

            checkWebSerialSupport() {
                if (!('serial' in navigator)) {
                    this.addToTerminal('❌ Web Serial API wird nicht unterstützt. Bitte verwende Chrome oder Edge.\n');
                }
            }

            initializeEventListeners() {
                document.getElementById('connectBtn').addEventListener('click', () => this.toggleConnection());
                document.getElementById('runBtn').addEventListener('click', () => this.runCode());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopExecution());
                document.getElementById('uploadBtn').addEventListener('click', () => this.showUploadModal());
                document.getElementById('listFilesBtn').addEventListener('click', () => this.listFiles());
                document.getElementById('softResetBtn').addEventListener('click', () => this.softReset());
                document.getElementById('clearTerminalBtn').addEventListener('click', () => this.clearTerminal());
                document.getElementById('terminalInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendCommand();
                });
                document.getElementById('saveFileBtn').addEventListener('click', () => this.uploadFile());

                // F5 für Ausführen
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'F5') {
                        e.preventDefault();
                        if (this.isConnected) this.runCode();
                    }
                });

                // Editor Änderungen speichern
                this.editor.onDidChangeModelContent(() => {
                    this.files[this.currentFile] = this.editor.getValue();
                });

                document.getElementById('deepSeekApiKeyInput').addEventListener('input', (e) => {
                    this.deepSeekApiKey = e.target.value;
                    localStorage.setItem('deepSeekApiKey', this.deepSeekApiKey);
                });

                document.getElementById('sendToLlmBtn').addEventListener('click', () => this.callDeepSeekApi());
                document.getElementById('acceptLlmChangesBtn').addEventListener('click', () => this.acceptLLMChanges());
                document.getElementById('rejectLlmChangesBtn').addEventListener('click', () => this.rejectLLMChanges());

                this.initializeResizer();
            }

            initializeResizer() {
                const resizer = document.getElementById('resizerVertical');
                const editorPanel = document.getElementById('editorPanel');
                const terminalPanel = document.getElementById('terminalPanel');
                const fileBrowser = document.querySelector('.file-browser');

                let initialX = 0;
                let initialTerminalWidth = 0;

                const onMouseMove = (e) => {
                    const dx = e.clientX - initialX;
                    let newTerminalWidth = initialTerminalWidth - dx;

                    const mainContentWidth = resizer.parentElement.offsetWidth;
                    const fileBrowserWidth = fileBrowser.offsetWidth;
                    const resizerWidth = resizer.offsetWidth;
                    
                    const minPanelPixelWidth = 150; // Mindestbreite für Editor und Terminal in Pixeln

                    const maxTerminalWidth = mainContentWidth - fileBrowserWidth - resizerWidth - minPanelPixelWidth;
                    
                    if (newTerminalWidth < minPanelPixelWidth) {
                        newTerminalWidth = minPanelPixelWidth;
                    }
                    if (newTerminalWidth > maxTerminalWidth) {
                        newTerminalWidth = maxTerminalWidth;
                    }
                    
                    const currentEditorWidth = mainContentWidth - fileBrowserWidth - resizerWidth - newTerminalWidth;
                    if (currentEditorWidth < minPanelPixelWidth) {
                        newTerminalWidth = mainContentWidth - fileBrowserWidth - resizerWidth - minPanelPixelWidth;
                        if (newTerminalWidth < minPanelPixelWidth) newTerminalWidth = minPanelPixelWidth; // Erneut prüfen
                    }

                    terminalPanel.style.flexBasis = `${newTerminalWidth}px`;

                    if (this.editor && typeof this.editor.layout === 'function') {
                        this.editor.layout();
                    }
                };

                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    document.body.style.cursor = 'default';
                    document.body.style.userSelect = 'auto';
                };

                resizer.addEventListener('mousedown', (e) => {
                    e.preventDefault(); // Verhindert Textauswahl während des Ziehens
                    initialX = e.clientX;
                    initialTerminalWidth = terminalPanel.offsetWidth;

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                    document.body.style.cursor = 'col-resize'; // Zeigt den Cursor global an
                    document.body.style.userSelect = 'none'; // Verhindert Textauswahl global
                });
            }

            async callDeepSeekApi() {
                const prompt = document.getElementById('llmPromptInput').value;
                const originalCode = this.editor.getValue(); // Originalcode speichern

                if (!this.deepSeekApiKey) {
                    this.addToTerminal('\n❌ Bitte zuerst einen DeepSeek API Key eingeben.\n');
                    console.error('DeepSeek API Key fehlt.');
                    alert('Bitte zuerst einen DeepSeek API Key im Feld oben rechts eingeben.');
                    return;
                }

                if (!prompt) {
                    this.addToTerminal('\nℹ️ Bitte einen Prompt für DeepSeek eingeben.\n');
                    alert('Bitte einen Prompt für DeepSeek eingeben.');
                    return;
                }

                this.addToTerminal('\n🤖 Sende Anfrage an DeepSeek...\n');
                const sendToLlmBtn = document.getElementById('sendToLlmBtn');
                sendToLlmBtn.disabled = true;
                sendToLlmBtn.innerHTML = '<span class="spinner"></span> Sende...';

                const API_URL = `https://api.deepseek.com/chat/completions`;
                const systemPrompt = "You are a helpful assistant that generates MicroPython code for microcontrollers. Ensure the code is valid MicroPython and directly usable on devices like ESP32. Only output the Python code, without any surrounding text or explanations unless explicitly asked.";

                const requestBody = {
                    model: "deepseek-chat",
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: `${prompt}\n\nAktueller Code im Editor (falls vorhanden, ansonsten generiere neuen Code):\n\`\`\`python\n${currentCode}\n\`\`\`` }
                    ],
                    temperature: 0.7,
                    // max_tokens: 2048, // Kann bei Bedarf angepasst werden
                };

                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.deepSeekApiKey}`
                        },
                        body: JSON.stringify(requestBody),
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error('DeepSeek API Error Response:', errorData);
                        this.addToTerminal(`\n❌ Fehler von DeepSeek API: ${response.status} ${response.statusText}\nDetails: ${JSON.stringify(errorData.error?.message || errorData)}\n`);
                        throw new Error(`API request failed with status ${response.status}: ${JSON.stringify(errorData)}`);
                    }

                    const data = await response.json();
                    console.log('DeepSeek API Success Response:', data);

                    if (data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
                        let llmOutput = data.choices[0].message.content;
                        
                        // Versuche, reinen Code aus Markdown-Codeblöcken zu extrahieren
                        const codeBlockMatch = llmOutput.match(/```python\n([\s\S]*?)\n```|```([\s\S]*?)\n```/);
                        let newCode = llmOutput; 

                        if (codeBlockMatch) {
                            newCode = codeBlockMatch[1] || codeBlockMatch[2]; 
                            const textBefore = llmOutput.substring(0, codeBlockMatch.index).trim();
                            const textAfter = llmOutput.substring(codeBlockMatch.index + codeBlockMatch[0].length).trim();
                            if (textBefore) console.log("LLM Info (vor Codeblock):", textBefore);
                            if (textAfter) console.log("LLM Info (nach Codeblock):", textAfter);
                        } else {
                             // Wenn kein expliziter Codeblock, aber die Ausgabe mit "python" beginnt (manchmal bei DeepSeek)
                             if (llmOutput.toLowerCase().startsWith("python\n")) {
                                 newCode = llmOutput.substring("python\n".length);
                             }
                             console.log("LLM Info (kein expliziter Python-Codeblock gefunden, verwende angepasste/gesamte Ausgabe als Code):", llmOutput);
                        }
                        
                        // Entferne mögliche einleitende/abschließende Leerzeilen, die vom LLM kommen könnten
                        newCode = newCode.trim();

                        // Diff-Ansicht anzeigen, anstatt den Editor direkt zu aktualisieren
                        this.showDiff(originalCode, newCode);
                        this.addToTerminal('\n✅ Code vom LLM erhalten. Bitte überprüfen Sie die Änderungen.\n');
                        // document.getElementById('llmPromptInput').value = ''; // Wird jetzt in hideDiffAndRestoreEditor gemacht
                    } else {
                        console.warn('DeepSeek API: Keine gültigen Kandidaten in der Antwort gefunden.', data);
                        this.addToTerminal('\n⚠️ DeepSeek hat keinen Code oder eine unerwartete Antwortstruktur zurückgegeben.\n');
                    }

                } catch (error) {
                    console.error('Fehler bei der Anfrage an DeepSeek API:', error);
                    this.addToTerminal(`\n❌ Fehler bei der Kommunikation mit DeepSeek: ${error.message}\n`);
                } finally {
                    sendToLlmBtn.disabled = false;
                    sendToLlmBtn.innerHTML = 'An DeepSeek senden';
                }
            }

            async toggleConnection() {
                if (this.isConnected) {
                    await this.disconnect();
                } else {
                    await this.connect();
                }
            }

            async connect() {
                try {
                    this.addToTerminal('🔌 Verbinde mit ESP32...\n');
                    
                    this.port = await navigator.serial.requestPort();
                    await this.port.open({ baudRate: 115200 });

                    this.reader = this.port.readable.getReader();
                    this.writer = this.port.writable.getWriter();

                    this.isConnected = true;
                    this.updateUI();
                    
                    this.addToTerminal('✅ Erfolgreich verbunden!\n');
                    
                    // REPL starten
                    await this.sendRawCommand('\x03\x03\x02'); // Ctrl+C, Ctrl+C, Ctrl+B
                    
                    this.startReading();
                    
                } catch (error) {
                    this.addToTerminal(`❌ Verbindungsfehler: ${error.message}\n`);
                }
            }

            async disconnect() {
                try {
                    if (this.reader) {
                        await this.reader.cancel();
                        this.reader.releaseLock();
                    }
                    if (this.writer) {
                        this.writer.releaseLock();
                    }
                    if (this.port) {
                        await this.port.close();
                    }
                    
                    this.isConnected = false;
                    this.updateUI();
                    this.addToTerminal('🔌 Verbindung getrennt\n');
                    
                } catch (error) {
                    this.addToTerminal(`❌ Fehler beim Trennen: ${error.message}\n`);
                }
            }

            async startReading() {
                try {
                    let buffer = '';
                    while (this.isConnected) {
                        const { value, done } = await this.reader.read();
                        if (done) break;
                        
                        const text = new TextDecoder().decode(value);
                        this.addToTerminal(text);
                        
                        // Check for file list output
                        buffer += text;
                        if (buffer.includes('===FILELIST_END===')) {
                            const files = this.parseFileList(buffer);
                            if (files) {
                                this.updateFileBrowser(files);
                            }
                            buffer = '';
                        }
                        
                        // Check for file content output
                        if (buffer.includes('===FILE_CONTENT_END===')) {
                            const content = this.parseFileContent(buffer);
                            if (content) {
                                this.editor.setValue(content);
                                this.files[this.currentFile] = content;
                            }
                            buffer = '';
                        }
                    }
                } catch (error) {
                    if (this.isConnected) {
                        this.addToTerminal(`❌ Lesefehler: ${error.message}\n`);
                    }
                }
            }

            async sendRawCommand(command) {
                if (!this.writer) return;
                
                const encoder = new TextEncoder();
                await this.writer.write(encoder.encode(command));
            }

            async sendCommand() {
                const input = document.getElementById('terminalInput');
                const command = input.value;
                
                if (!command.trim()) return;
                
                this.addToTerminal(`>>> ${command}\n`);
                await this.sendRawCommand(command + '\r\n');
                
                input.value = '';
            }

            async runCode() {
                if (!this.isConnected) return;
                
                if (!this.currentFile) {
                    this.addToTerminal('\n❌ Bitte erst eine Datei hochladen\n');
                    return;
                }
                
                this.addToTerminal(`\n=== Führe ${this.currentFile} aus ===\n`);
                
                // Code ausführen mittels Paste-Modus und exec
                await this.sendRawCommand('\r\n'); // Sicherstellen, dass die REPL-Zeile frei ist
                await new Promise(resolve => setTimeout(resolve, 50));

                // Construct the script with \r line endings for paste mode

                const pythonScriptSource = `try:
    with open('${this.currentFile}', 'r') as f:
        exec(f.read())
except OSError:
    print("Error: ${this.currentFile} not found")
except SyntaxError as e:
    print(f"SyntaxError in ${this.currentFile}: {e}")
`;
                const pythonScript = pythonScriptSource.replace(/\n/g, '\r') + '\r';                

                await this.sendRawCommand('\x05'); // Ctrl-E: Paste-Modus starten
                await new Promise(resolve => setTimeout(resolve, 100)); // Kurze Pause
                
                await this.sendRawCommand(pythonScript);
                // Keine zusätzliche Pause hier, da der gesamte Block auf einmal gesendet wird
                
                await this.sendRawCommand('\x04'); // Ctrl-D: Paste-Modus beenden und ausführen
                await new Promise(resolve => setTimeout(resolve, 100)); // Kurze Pause danach
            }

            async stopExecution() {
                if (!this.isConnected) return;
                
                this.addToTerminal('\n🛑 Stoppe Ausführung...\n');
                await this.sendRawCommand('\x03'); // Ctrl+C
            }

            async softReset() {
                if (!this.isConnected) return;
                
                this.addToTerminal('\n🔄 Soft Reset...\n');
                await this.sendRawCommand('\x04'); // Ctrl+D
            }

            showUploadModal() {
                document.getElementById('filenameModal').style.display = 'block';
                document.getElementById('filenameInput').value = this.currentFile;
                document.getElementById('filenameInput').focus();
                // Fortschrittsbalken zurücksetzen und ausblenden
                const progressBarContainer = document.getElementById('uploadProgressBarContainer');
                const progressBar = document.getElementById('uploadProgressBar');
                progressBar.style.width = '0%';
                progressBar.textContent = '';
                progressBarContainer.style.display = 'none';
            }

            async uploadFile() {
                const filename = document.getElementById('filenameInput').value;
                if (!filename) return;
                if (!filename.endsWith('.py')) {
                    this.addToTerminal('\n❌ Dateiname muss mit .py enden\n');
                    return;
                }
                
                const code = this.editor.getValue();
                this.currentFile = filename;
                const chunkSize = 200; // Noch kleinere Chunk-Größe
                const totalChunks = Math.ceil(code.length / chunkSize);

                const progressBarContainer = document.getElementById('uploadProgressBarContainer');
                const progressBar = document.getElementById('uploadProgressBar');
                progressBar.style.width = '0%';
                progressBar.textContent = '0%';
                progressBarContainer.style.display = 'block';
                
                this.addToTerminal(`\n📤 Lade ${filename} hoch (${code.length} Zeichen, ${totalChunks} Teile)...\n`);
                this.addToTerminal('⚠️ Bitte warten während die Datei hochgeladen wird...\n');
                
                try {
                    // Datei erstellen
                    await this.sendRawCommand('\x05');
                    await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                    await this.sendRawCommand(`f=open('${filename}','w')\r\n`);
                    await this.sendRawCommand('\x04');
                    await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                    
                    // Code in Chunks hochladen
                    for (let i = 0; i < totalChunks; i++) {
                        const chunk = code.substring(i * chunkSize, (i + 1) * chunkSize);
                        // Sonderzeichen escapen
                        const escapedChunk = chunk
                            .replace(/\\/g, '\\\\')
                            .replace(/'/g, "\\'")
                            .replace(/\r/g, '\\r')
                            .replace(/\n/g, '\\n');
                        
                        try {
                            await this.sendRawCommand('\x05');
                            await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                            await this.sendRawCommand(`f.write('${escapedChunk}')\r\n`);
                            await this.sendRawCommand('\x04');
                            await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                            
                            // Fortschritt anzeigen
                            const progress = Math.round(((i + 1) / totalChunks) * 100);
                            this.addToTerminal(`\r🔼 Hochgeladen: ${progress}% (${(i + 1) * chunkSize}/${code.length})`);
                            progressBar.style.width = progress + '%';
                            progressBar.textContent = progress + '%';
                        } catch (error) {
                            this.addToTerminal(`\n❌ Fehler bei Chunk ${i+1}: ${error.message}\n`);
                            progressBarContainer.style.display = 'none'; // Fortschrittsbalken bei Fehler ausblenden
                            throw error;
                        }
                    }
                    
                    // Datei schließen
                    await this.sendRawCommand('\x05');
                    await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                    await this.sendRawCommand('f.close()\r\n');
                    await this.sendRawCommand('\x04');
                    await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                    
                    this.addToTerminal(`\n✅ ${filename} erfolgreich hochgeladen!\n`);
                    progressBar.textContent = '100%'; // Sicherstellen, dass es 100% anzeigt
                    
                } catch (error) {
                    this.addToTerminal(`\n❌ Fehler beim Hochladen: ${error.message}\n`);
                    progressBarContainer.style.display = 'none'; // Fortschrittsbalken bei Fehler ausblenden
                } finally {
                    // Kurze Verzögerung, bevor das Modal geschlossen wird, damit der Benutzer 100% sieht
                    setTimeout(() => {
                        closeModal();
                        // Fortschrittsbalken für das nächste Mal ausblenden (wird auch in showUploadModal gemacht, aber sicher ist sicher)
                        progressBarContainer.style.display = 'none';
                        progressBar.style.width = '0%';
                        progressBar.textContent = '';
                    }, 500);
                    setTimeout(() => this.listFiles(), 1000); // listFiles nach dem Schließen des Modals
                }
            }

            async loadFile(filename) {
                if (!this.isConnected) return;
                
                this.addToTerminal(`\n📥 Lade ${filename}...\n`);
                
                const loadCode = `
try:
    with open('${filename}', 'r') as f:
        print('===FILE_CONTENT_START===')
        print(f.read())
        print('===FILE_CONTENT_END===')
except Exception as e:
    print('Fehler:', e)
`;
                
                await this.sendRawCommand('\x05');
                await new Promise(resolve => setTimeout(resolve, 100));
                await this.sendRawCommand(loadCode);
                await this.sendRawCommand('\x04');
                
                // Datei im Editor anzeigen
                this.currentFile = filename;
                this.editor.setValue('');
            }

            parseFileContent(text) {
                const startMarker = '===FILE_CONTENT_START===';
                const endMarker = '===FILE_CONTENT_END===';
                
                const start = text.indexOf(startMarker);
                const end = text.indexOf(endMarker);
                
                if (start === -1 || end === -1) return null;
                
                let content = text.substring(start + startMarker.length, end);
                // Normalisiere Zeilenenden (CRLF -> LF)
                content = content.replace(/\r\n/g, '\n');
                // Entferne überflüssige Leerzeilen am Anfang und Ende
                content = content.replace(/^\n+|\n+$/g, '');
                return content;
            }

            async listFiles() {
                if (!this.isConnected) return;
                
                this.addToTerminal('\n📁 Dateien werden aufgelistet...\n');
                
                const listCode = `
import os
print('===FILELIST_START===')
for file in os.listdir():
    try:
        stat = os.stat(file)
        size = stat[6]
        print(f'{file}|{size}')
    except:
        print(f'{file}|folder')
print('===FILELIST_END===')
`;
                
                await this.sendRawCommand('\x05');
                await new Promise(resolve => setTimeout(resolve, 100));
                await this.sendRawCommand(listCode);
                await this.sendRawCommand('\x04');
            }

            parseFileList(text) {
                const startMarker = '===FILELIST_START===';
                const endMarker = '===FILELIST_END===';
                
                const start = text.indexOf(startMarker);
                const end = text.indexOf(endMarker);
                
                if (start === -1 || end === -1) return null;
                
                const fileListText = text.substring(start + startMarker.length, end).trim();
                const lines = fileListText.split('\n');
                
                const files = [];
                for (const line of lines) {
                    const [name, size] = line.split('|');
                    files.push({name, size});
                }
                
                return files;
            }

            updateFileBrowser(files) {
                const fileListElement = document.getElementById('fileList');
                fileListElement.innerHTML = '';
                
                files.forEach(file => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.textContent = `${file.name} (${file.size === 'folder' ? 'Ordner' : file.size + ' bytes'})`;
                    fileItem.addEventListener('click', () => this.loadFile(file.name));
                    fileListElement.appendChild(fileItem);
                });
            }

            addToTerminal(text) {
                const terminal = document.getElementById('terminal');
                terminal.textContent += text;
                terminal.scrollTop = terminal.scrollHeight;
            }

            clearTerminal() {
                document.getElementById('terminal').textContent = '';
            }

            updateUI() {
                const connectBtn = document.getElementById('connectBtn');
                const status = document.getElementById('status');
                const buttons = ['runBtn', 'stopBtn', 'uploadBtn', 'listFilesBtn', 'softResetBtn'];
                const terminalInput = document.getElementById('terminalInput');
                
                if (this.isConnected) {
                    connectBtn.textContent = 'Trennen';
                    status.textContent = 'Verbunden';
                    status.className = 'status connected';
                    buttons.forEach(id => document.getElementById(id).disabled = false);
                    terminalInput.disabled = false;
                } else {
                    connectBtn.textContent = 'Mit ESP32 verbinden';
                    status.textContent = 'Nicht verbunden';
                    status.className = 'status disconnected';
                    buttons.forEach(id => document.getElementById(id).disabled = true);
                    terminalInput.disabled = true;
                }
            }
        }

        function closeModal() {
            document.getElementById('filenameModal').style.display = 'none';
        }

        // Monaco Editor initialisieren
        function initEditor() {
            try {
                require(['vs/editor/editor.main'], function() {
                    const editor = monaco.editor.create(document.getElementById('editor'), {
                        value: [
                            "# Dein MicroPython Code hier...",
                            "print('Hello ESP32!')",
                            "",
                            "# Beispiel: LED blinken",
                            "from machine import Pin",
                            "import time",
                            "",
                            "led = Pin(2, Pin.OUT)  # GPIO 2 für eingebaute LED",
                            "",
                            "for i in range(10):",
                            "    led.on()",
                            "    time.sleep(0.5)",
                            "    led.off()",
                            "    time.sleep(0.5)",
                            "    print('Blink ' + str(i + 1))  # f-string removed for wider compatibility"
                        ].join('\n'),
                        language: 'python',
                        theme: 'vs-dark',
                        automaticLayout: true,
                        minimap: { enabled: false },
                        fontSize: 14,
                        lineNumbers: 'on',
                        roundedSelection: true,
                        scrollBeyondLastLine: false,
                        renderWhitespace: 'selection',
                        tabSize: 4
                    });

                    // IDE initialisieren und Editor übergeben
                    window.ide = new MicroPythonIDE(editor);
                });
            } catch (error) {
                console.error('Editor Initialization Error:', error);
                // Fallback falls Monaco nicht lädt
                const editorElement = document.getElementById('editor');
                editorElement.innerHTML = '<textarea style="width:100%;height:100%;background:#1e1e1e;color:#d4d4d4;border:none;padding:10px;font-family:monospace;font-size:14px;" id="fallbackEditor"># Dein MicroPython Code hier...\nprint(\'Hello ESP32!\')</textarea>';
                window.ide = new MicroPythonIDE({
                    getValue: () => document.getElementById('fallbackEditor').value,
                    setValue: (content) => document.getElementById('fallbackEditor').value = content,
                    onDidChangeModelContent: (callback) => {
                        document.getElementById('fallbackEditor').addEventListener('input', callback);
                    }
                });
            }
        }

        // Editor laden wenn alles fertig ist
        if (document.readyState === 'complete') {
            initEditor();
        } else {
            window.addEventListener('load', initEditor);
        }
    </script>
</body>
</html>
