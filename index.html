<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MicroPython Web IDE</title>
    <!-- Monaco Editor -->
    <link rel="stylesheet" data-name="vs/editor/editor.main" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/editor/editor.main.min.css">
    <script>
        var require = { paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs' } };
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/loader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/editor/editor.main.nls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/editor/editor.main.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            background: #2d2d30;
            padding: 10px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .btn {
            background: #0e639c;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #1177bb;
        }

        .btn:disabled {
            background: #555;
            cursor: not-allowed;
        }

        .btn.danger {
            background: #d73a49;
        }

        .btn.danger:hover {
            background: #e85565;
        }

        .status {
            margin-left: auto;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .status.connected {
            background: #28a745;
        }

        .status.disconnected {
            background: #dc3545;
        }

        .main-content {
            display: flex;
            flex: 1;
            min-height: 0;
        }

        .editor-panel {
            flex: 1; /* Nimmt verf√ºgbaren Platz ein */
            display: flex;
            flex-direction: column;
            min-width: 200px; /* Mindestbreite f√ºr den Editor */
        }

        #resizerVertical {
            width: 5px;
            background-color: #3e3e42;
            cursor: col-resize;
            flex-shrink: 0; /* Verhindert, dass der Resizer schrumpft */
        }

        .file-tabs {
            background: #2d2d30;
            padding: 0;
            border-bottom: 1px solid #3e3e42;
            display: flex;
        }

        .tab {
            background: #3c3c3c;
            border: none;
            color: #d4d4d4;
            padding: 8px 16px;
            cursor: pointer;
            border-right: 1px solid #3e3e42;
            font-size: 12px;
        }

        .tab.active {
            background: #1e1e1e;
        }

        #editor-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .terminal-panel {
            /* width: 40%; wird durch flex-basis ersetzt */
            flex: 0 0 40%; /* Nicht wachsen, nicht schrumpfen, Basisbreite 40% */
            display: flex;
            flex-direction: column;
            min-width: 150px; /* Mindestbreite f√ºr das Terminal */
            background: #0c0c0c;
        }

        .terminal-header {
            background: #2d2d30;
            padding: 8px 12px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .terminal {
            flex: 1;
            background: #0c0c0c;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .terminal-input {
            background: #0c0c0c;
            border: none;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            outline: none;
            border-top: 1px solid #3e3e42;
        }

        .file-browser {
            width: 200px;
            flex-shrink: 0; /* Verhindert, dass der File-Browser schrumpft */
            background: #252526;
            border-right: 1px solid #3e3e42;
            padding: 10px;
            overflow-y: auto;
        }

        .file-item {
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
        }

        .file-item:hover {
            background: #2a2d2e;
        }

        .file-item.selected {
            background: #094771;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .modal-content {
            background: #2d2d30;
            margin: 15% auto;
            padding: 20px;
            border-radius: 8px;
            width: 300px;
            color: #d4d4d4;
        }

        .modal input {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            color: #d4d4d4;
            border-radius: 4px;
        }

        .spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #555;
            border-top: 2px solid #0e639c;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .prompt-panel {
            display: flex;
            padding: 10px;
            background: #2d2d30;
            border-top: 1px solid #3e3e42;
        }

        .prompt-panel input {
            flex-grow: 1;
            padding: 8px;
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            color: #d4d4d4;
            border-radius: 4px;
            font-size: 12px;
            margin-right: 10px;
        }

        .context-menu-item {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 12px;
            color: #d4d4d4;
        }
        .context-menu-item:hover {
            background-color: #0e639c;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <button class="btn" id="connectBtn">Mit ESP32 verbinden</button>
        <button class="btn" id="newFileBtn">Neu</button> 
        <button class="btn" id="runBtn" disabled>Ausf√ºhren (F5)</button>
        <button class="btn" id="stopBtn" disabled>Stopp</button>
        <button class="btn" id="uploadBtn" disabled>Hochladen</button> <!-- Bleibt initial disabled -->
        <button class="btn" id="listFilesBtn" disabled>Dateien auflisten</button>
        <button class="btn danger" id="softResetBtn" disabled>Soft Reset</button>
        <input type="password" id="deepSeekApiKeyInput" placeholder="DeepSeek API Key" style="margin-left: 10px; padding: 8px; background: #1e1e1e; border: 1px solid #3e3e42; color: #d4d4d4; border-radius: 4px; font-size: 12px; min-width: 150px;">
        <div id="llmUsageStats" style="margin-left: 10px; font-size: 10px; display: flex; gap: 8px; align-items: center;">
            <span>P: <span id="promptTokens">0</span></span>
            <span>C: <span id="completionTokens">0</span></span>
            <span>T: <span id="totalTokens">0</span></span>
            <span>Cost: <span id="lastCost">0.00</span>¬µ</span>
            <span>Total: <span id="totalSessionCost">0.00</span>¬µ</span>
        </div>
        <div class="status disconnected" id="status">Nicht verbunden</div>
    </div>

    <div class="main-content">
        <div class="file-browser">
            <h4 style="margin-bottom: 10px;">Dateien auf ESP32</h4>
            <div id="fileList"></div>
        </div>

        <div class="editor-panel" id="editorPanel">
            <div class="file-tabs">
                <button class="tab active" data-file="main.py">main.py</button>
            </div>
            <div id="editor-container">
                <div id="editor" style="height:100%"></div>
            </div>
            <div class="prompt-panel">
                <input type="text" id="llmPromptInput" placeholder="Prompt f√ºr DeepSeek eingeben...">
                <button class="btn" id="sendToLlmBtn">An DeepSeek senden</button>
                <button class="btn" id="acceptLlmChangesBtn" style="display: none; margin-left: 10px;">√Ñnderungen √ºbernehmen</button>
                <button class="btn danger" id="rejectLlmChangesBtn" style="display: none; margin-left: 10px;">Ablehnen</button>
            </div>
        </div>

        <div id="resizerVertical"></div>

        <div class="terminal-panel" id="terminalPanel">
            <div class="terminal-header">
                <span>REPL Terminal</span>
                <button class="btn" id="clearTerminalBtn">L√∂schen</button>
            </div>
            <div class="terminal" id="terminal">Bereit f√ºr Verbindung...\n</div>
            <input class="terminal-input" id="terminalInput" placeholder=">>> MicroPython Befehl eingeben..." disabled>
        </div>
    </div>

    <!-- Modal f√ºr Dateinamen -->
    <div class="modal" id="filenameModal">
        <div class="modal-content">
            <h3>Datei speichern als:</h3>
            <input type="text" id="filenameInput" placeholder="dateiname.py">
            <div id="uploadProgressBarContainer" style="margin-top: 10px; background-color: #1e1e1e; border-radius: 4px; display: none;">
                <div id="uploadProgressBar" style="width: 0%; height: 10px; background-color: #0e639c; border-radius: 4px; text-align: center; line-height: 10px; font-size: 8px; color: white;"></div>
            </div>
            <div style="margin-top: 15px;">
                <button class="btn" id="saveFileBtn">Speichern</button>
                <button class="btn" onclick="closeModal()">Abbrechen</button>
            </div>
        </div>
    </div>

    <script>
        class MicroPythonIDE {
            constructor(editor) {
                this.port = null;
                this.reader = null;
                this.writer = null;
                this.isConnected = false;
                this.currentFile = 'main.py';
                this.editor = editor;
                this.files = {'main.py': this.editor.getValue()};
                this.deepSeekApiKey = localStorage.getItem('deepSeekApiKey') || '';
                this.diffEditor = null;
                this.diffEditorContainerDiv = null;
                this.originalEditorDiv = document.getElementById('editor');
                this.editorContainerDiv = document.getElementById('editor-container');
                this.totalSessionCostUnits = 0; // F√ºr die Kostensummierung
                this.contextMenuTargetFile = null;
                this.deviceFiles = []; // Zum Speichern der aktuellen Dateiliste vom Ger√§t
                this.hardwareContext = ''; // F√ºr den Inhalt von hardware.txt
                this.isLoadingHardwareContext = false; // Flag f√ºr das Laden von hardware.txt
                
                this.initializeEventListeners();
                this.checkWebSerialSupport();
                document.getElementById('deepSeekApiKeyInput').value = this.deepSeekApiKey;
            }

            checkWebSerialSupport() {
                if (!('serial' in navigator)) {
                    this.addToTerminal('‚ùå Web Serial API wird nicht unterst√ºtzt. Bitte verwende Chrome oder Edge.\n');
                }
            }

            initializeEventListeners() {
                document.getElementById('connectBtn').addEventListener('click', () => this.toggleConnection());
                document.getElementById('runBtn').addEventListener('click', () => this.runCode());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopExecution());
                document.getElementById('uploadBtn').addEventListener('click', () => this.showUploadModal());
                document.getElementById('listFilesBtn').addEventListener('click', () => this.listFiles());
                document.getElementById('softResetBtn').addEventListener('click', () => this.softReset());
                document.getElementById('clearTerminalBtn').addEventListener('click', () => this.clearTerminal());
                document.getElementById('terminalInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendCommand();
                });
                document.getElementById('saveFileBtn').addEventListener('click', () => this.uploadFile());
                document.getElementById('newFileBtn').addEventListener('click', () => this.newFile());

                // F5 f√ºr Ausf√ºhren
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'F5') {
                        e.preventDefault();
                        if (this.isConnected) this.runCode();
                    }
                });

                // Editor √Ñnderungen speichern
                this.editor.onDidChangeModelContent(() => {
                    this.files[this.currentFile] = this.editor.getValue();
                });

                document.getElementById('deepSeekApiKeyInput').addEventListener('input', (e) => {
                    this.deepSeekApiKey = e.target.value;
                    localStorage.setItem('deepSeekApiKey', this.deepSeekApiKey);
                });

                document.getElementById('sendToLlmBtn').addEventListener('click', () => this.callDeepSeekApi());
                document.getElementById('acceptLlmChangesBtn').addEventListener('click', () => this.acceptLLMChanges());
                document.getElementById('rejectLlmChangesBtn').addEventListener('click', () => this.rejectLLMChanges());

                this.initializeResizer();
                this.initializeContextMenuListeners();
            }

            initializeContextMenuListeners() {
                const contextMenu = document.getElementById('fileContextMenu');
                document.addEventListener('click', (e) => { // Globaler Klick zum Schlie√üen
                    if (!contextMenu.contains(e.target)) {
                        contextMenu.style.display = 'none';
                        this.contextMenuTargetFile = null;
                    }
                });

                contextMenu.querySelectorAll('.context-menu-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        const action = e.target.dataset.action;
                        if (this.contextMenuTargetFile) {
                            switch (action) {
                                case 'delete':
                                    this.promptDeleteFile(this.contextMenuTargetFile);
                                    break;
                                case 'rename':
                                    this.promptRenameFile(this.contextMenuTargetFile);
                                    break;
                            }
                        }
                        contextMenu.style.display = 'none';
                        this.contextMenuTargetFile = null;
                    });
                });
            }

            initializeResizer() {
                const resizer = document.getElementById('resizerVertical');
                const editorPanel = document.getElementById('editorPanel');
                const terminalPanel = document.getElementById('terminalPanel');
                const fileBrowser = document.querySelector('.file-browser');

                let initialX = 0;
                let initialTerminalWidth = 0;

                const onMouseMove = (e) => {
                    const dx = e.clientX - initialX;
                    let newTerminalWidth = initialTerminalWidth - dx;

                    const mainContentWidth = resizer.parentElement.offsetWidth;
                    const fileBrowserWidth = fileBrowser.offsetWidth;
                    const resizerWidth = resizer.offsetWidth;
                    
                    const minPanelPixelWidth = 150; // Mindestbreite f√ºr Editor und Terminal in Pixeln

                    const maxTerminalWidth = mainContentWidth - fileBrowserWidth - resizerWidth - minPanelPixelWidth;
                    
                    if (newTerminalWidth < minPanelPixelWidth) {
                        newTerminalWidth = minPanelPixelWidth;
                    }
                    if (newTerminalWidth > maxTerminalWidth) {
                        newTerminalWidth = maxTerminalWidth;
                    }
                    
                    const currentEditorWidth = mainContentWidth - fileBrowserWidth - resizerWidth - newTerminalWidth;
                    if (currentEditorWidth < minPanelPixelWidth) {
                        newTerminalWidth = mainContentWidth - fileBrowserWidth - resizerWidth - minPanelPixelWidth;
                        if (newTerminalWidth < minPanelPixelWidth) newTerminalWidth = minPanelPixelWidth; // Erneut pr√ºfen
                    }

                    terminalPanel.style.flexBasis = `${newTerminalWidth}px`;

                    if (this.editor && typeof this.editor.layout === 'function') {
                        this.editor.layout();
                    }
                };

                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    document.body.style.cursor = 'default';
                    document.body.style.userSelect = 'auto';
                };

                resizer.addEventListener('mousedown', (e) => {
                    e.preventDefault(); // Verhindert Textauswahl w√§hrend des Ziehens
                    initialX = e.clientX;
                    initialTerminalWidth = terminalPanel.offsetWidth;

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                    document.body.style.cursor = 'col-resize'; // Zeigt den Cursor global an
                    document.body.style.userSelect = 'none'; // Verhindert Textauswahl global
                });
            }

            async callDeepSeekApi() {
                const prompt = document.getElementById('llmPromptInput').value;
                const originalCode = this.editor.getValue(); // Originalcode speichern

                if (!this.deepSeekApiKey) {
                    this.addToTerminal('\n‚ùå Bitte zuerst einen DeepSeek API Key eingeben.\n');
                    console.error('DeepSeek API Key fehlt.');
                    alert('Bitte zuerst einen DeepSeek API Key im Feld oben rechts eingeben.');
                    return;
                }

                if (!prompt) {
                    this.addToTerminal('\n‚ÑπÔ∏è Bitte einen Prompt f√ºr DeepSeek eingeben.\n');
                    alert('Bitte einen Prompt f√ºr DeepSeek eingeben.');
                    return;
                }

                this.addToTerminal('\nü§ñ Sende Anfrage an DeepSeek...\n');
                const sendToLlmBtn = document.getElementById('sendToLlmBtn');
                sendToLlmBtn.disabled = true;
                sendToLlmBtn.innerHTML = '<span class="spinner"></span> Sende...';

                const API_URL = `https://api.deepseek.com/chat/completions`;
                const systemPrompt = "You are a helpful assistant that generates MicroPython code for microcontrollers. Ensure the code is valid MicroPython and directly usable on devices like ESP32. Only output the Python code, without any surrounding text or explanations unless explicitly asked.";
                
                let userPromptContent = `${prompt}\n\nAktueller Code im Editor (falls vorhanden, ansonsten generiere neuen Code):\n\`\`\`python\n${originalCode}\n\`\`\``;

                if (this.hardwareContext) {
                    userPromptContent = `Beachte die folgende Hardware-Konfiguration:\n<hardware_info>\n${this.hardwareContext}\n</hardware_info>\n\n${userPromptContent}`;
                    this.addToTerminal('\n‚ÑπÔ∏è Hardware-Kontext wird an LLM gesendet.\n');
                }

                const requestBody = {
                    model: "deepseek-chat",
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: userPromptContent }
                    ],
                    temperature: 0.7,
                    // max_tokens: 2048, // Kann bei Bedarf angepasst werden
                };

                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.deepSeekApiKey}`
                        },
                        body: JSON.stringify(requestBody),
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error('DeepSeek API Error Response:', errorData);
                        this.addToTerminal(`\n‚ùå Fehler von DeepSeek API: ${response.status} ${response.statusText}\nDetails: ${JSON.stringify(errorData.error?.message || errorData)}\n`);
                        throw new Error(`API request failed with status ${response.status}: ${JSON.stringify(errorData)}`);
                    }

                    const data = await response.json();
                    console.log('DeepSeek API Success Response:', data);

                    // Nutzungsdaten und Kosten aktualisieren
                    if (data.usage) {
                        const usage = data.usage;
                        const promptTokens = usage.prompt_tokens || 0;
                        const completionTokens = usage.completion_tokens || 0;
                        const totalTokens = usage.total_tokens || 0;

                        // Preise f√ºr deepseek-chat (angenommen, bitte verifizieren):
                        // Input: 1 RMB / 1M tokens => 0.000001 RMB / token
                        // Output: 2 RMB / 1M tokens => 0.000002 RMB / token
                        // Wir verwenden "Mikro-Einheiten" (¬µ) zur Darstellung, wobei 1¬µ ~ 1 RMB / 1M Input Tokens
                        const costPerMillionInputTokens = 1; 
                        const costPerMillionOutputTokens = 2;

                        const currentCost = (promptTokens / 1000000) * costPerMillionInputTokens + 
                                          (completionTokens / 1000000) * costPerMillionOutputTokens;
                        
                        this.totalSessionCostUnits += currentCost;

                        document.getElementById('promptTokens').textContent = promptTokens;
                        document.getElementById('completionTokens').textContent = completionTokens;
                        document.getElementById('totalTokens').textContent = totalTokens;
                        document.getElementById('lastCost').textContent = currentCost.toFixed(6); // Zeigt z.B. 0.000123 an
                        document.getElementById('totalSessionCost').textContent = this.totalSessionCostUnits.toFixed(6);
                    } else {
                        // Reset, falls keine Nutzungsdaten vorhanden sind
                        document.getElementById('promptTokens').textContent = 'N/A';
                        document.getElementById('completionTokens').textContent = 'N/A';
                        document.getElementById('totalTokens').textContent = 'N/A';
                        document.getElementById('lastCost').textContent = 'N/A';
                    }

                    if (data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
                        let llmOutput = data.choices[0].message.content;
                        
                        // Versuche, reinen Code aus Markdown-Codebl√∂cken zu extrahieren
                        const codeBlockMatch = llmOutput.match(/```python\n([\s\S]*?)\n```|```([\s\S]*?)\n```/);
                        let newCode = llmOutput; 

                        if (codeBlockMatch) {
                            newCode = codeBlockMatch[1] || codeBlockMatch[2]; 
                            const textBefore = llmOutput.substring(0, codeBlockMatch.index).trim();
                            const textAfter = llmOutput.substring(codeBlockMatch.index + codeBlockMatch[0].length).trim();
                            if (textBefore) console.log("LLM Info (vor Codeblock):", textBefore);
                            if (textAfter) console.log("LLM Info (nach Codeblock):", textAfter);
                        } else {
                             // Wenn kein expliziter Codeblock, aber die Ausgabe mit "python" beginnt (manchmal bei DeepSeek)
                             if (llmOutput.toLowerCase().startsWith("python\n")) {
                                 newCode = llmOutput.substring("python\n".length);
                             }
                             console.log("LLM Info (kein expliziter Python-Codeblock gefunden, verwende angepasste/gesamte Ausgabe als Code):", llmOutput);
                        }
                        
                        // Entferne m√∂gliche einleitende/abschlie√üende Leerzeilen, die vom LLM kommen k√∂nnten
                        newCode = newCode.trim();

                        // Diff-Ansicht anzeigen, anstatt den Editor direkt zu aktualisieren
                        this.showDiff(originalCode, newCode);
                        this.addToTerminal('\n‚úÖ Code vom LLM erhalten. Bitte √ºberpr√ºfen Sie die √Ñnderungen.\n');
                        // document.getElementById('llmPromptInput').value = ''; // Wird jetzt in hideDiffAndRestoreEditor gemacht
                    } else {
                        console.warn('DeepSeek API: Keine g√ºltigen Kandidaten in der Antwort gefunden.', data);
                        this.addToTerminal('\n‚ö†Ô∏è DeepSeek hat keinen Code oder eine unerwartete Antwortstruktur zur√ºckgegeben.\n');
                    }

                } catch (error) {
                    console.error('Fehler bei der Anfrage an DeepSeek API:', error);
                    this.addToTerminal(`\n‚ùå Fehler bei der Kommunikation mit DeepSeek: ${error.message}\n`);
                } finally {
                    sendToLlmBtn.disabled = false;
                    sendToLlmBtn.innerHTML = 'An DeepSeek senden';
                }
            }

            showDiff(originalCode, newCode) {
                this.originalEditorDiv.style.display = 'none'; // Haupteditor ausblenden

                // Vorherigen Diff-Editor entfernen, falls vorhanden
                if (this.diffEditorContainerDiv) {
                    this.diffEditorContainerDiv.remove();
                }
                if (this.diffEditor) {
                    this.diffEditor.dispose(); // Wichtig: Monaco Editor Instanzen disposen
                    this.diffEditor = null;
                }

                this.diffEditorContainerDiv = document.createElement('div');
                this.diffEditorContainerDiv.style.width = '100%';
                this.diffEditorContainerDiv.style.height = '100%'; // Nimmt die volle H√∂he des Parents
                this.editorContainerDiv.appendChild(this.diffEditorContainerDiv);

                this.diffEditor = monaco.editor.createDiffEditor(this.diffEditorContainerDiv, {
                    theme: 'vs-dark',
                    automaticLayout: true,
                    readOnly: false, // Erlaube Bearbeitung in der "modified" Seite, falls gew√ºnscht
                    originalEditable: false, // Original sollte nicht bearbeitbar sein
                    renderSideBySide: true // Standard ist nebeneinander
                });

                const originalModel = monaco.editor.createModel(originalCode, 'python');
                const modifiedModel = monaco.editor.createModel(newCode, 'python');

                this.diffEditor.setModel({
                    original: originalModel,
                    modified: modifiedModel
                });

                // Buttons im Prompt-Panel umschalten
                document.getElementById('llmPromptInput').style.display = 'none';
                document.getElementById('sendToLlmBtn').style.display = 'none';
                document.getElementById('acceptLlmChangesBtn').style.display = 'inline-block';
                document.getElementById('rejectLlmChangesBtn').style.display = 'inline-block';
            }

            hideDiffAndRestoreEditor() {
                if (this.diffEditor) {
                    // Modelle explizit disposen, bevor der Editor disposed wird
                    const model = this.diffEditor.getModel();
                    if (model && model.original) model.original.dispose();
                    if (model && model.modified) model.modified.dispose();
                    this.diffEditor.dispose();
                    this.diffEditor = null;
                }
                if (this.diffEditorContainerDiv) {
                    this.diffEditorContainerDiv.remove();
                    this.diffEditorContainerDiv = null;
                }
                this.originalEditorDiv.style.display = 'block';
                this.editor.layout(); // Haupteditor neu zeichnen lassen

                // Buttons im Prompt-Panel zur√ºcksetzen
                document.getElementById('llmPromptInput').style.display = 'block'; // Zur√ºck zu block oder initial
                document.getElementById('llmPromptInput').style.flexGrow = '1'; // explizit wiederherstellen
                document.getElementById('sendToLlmBtn').style.display = 'inline-block';
                document.getElementById('sendToLlmBtn').disabled = false; // Sicherstellen, dass der Senden-Button wieder aktiv ist
                document.getElementById('acceptLlmChangesBtn').style.display = 'none';
                document.getElementById('rejectLlmChangesBtn').style.display = 'none';
                document.getElementById('llmPromptInput').value = ''; // Prompt-Feld leeren
            }

            acceptLLMChanges() {
                if (!this.diffEditor) return;
                const acceptedCode = this.diffEditor.getModel().modified.getValue();
                this.editor.setValue(acceptedCode);
                this.files[this.currentFile] = acceptedCode;
                this.addToTerminal('\n‚úÖ LLM-√Ñnderungen √ºbernommen.\n');
                this.hideDiffAndRestoreEditor();
            }

            rejectLLMChanges() {
                if (!this.diffEditor) return; // Sollte nicht passieren, aber sicher ist sicher
                this.addToTerminal('\n‚ùå LLM-√Ñnderungen abgelehnt.\n');
                this.hideDiffAndRestoreEditor();
            }

            updateActiveTab(filename) {
                const activeTab = document.querySelector('.file-tabs .tab.active');
                if (activeTab) {
                    activeTab.textContent = filename;
                    activeTab.dataset.file = filename;
                }
            }

            newFile() {
                if (this.diffEditor) { // Wenn in Diff-Ansicht, zuerst √Ñnderungen verwerfen
                    this.rejectLLMChanges(); 
                }
                this.editor.setValue('');
                this.currentFile = 'untitled.py'; // Standardm√§√üig .py
                this.files[this.currentFile] = '';
                this.updateActiveTab(this.currentFile);
                // Upload-Button aktivieren, wenn verbunden, da jetzt eine (leere) Datei zum Speichern vorhanden ist
                document.getElementById('uploadBtn').disabled = !this.isConnected;
                this.addToTerminal(`\n‚ú® Neue Datei '${this.currentFile}' im Editor erstellt.\n`);
            }

            async fetchHardwareContextFile() {
                if (!this.isConnected) return;
                this.addToTerminal('\n‚ÑπÔ∏è Versuche Hardware-Kontext (hardware.txt) zu laden...\n');
                this.isLoadingHardwareContext = true;
                this.hardwareContext = ''; // Alten Kontext l√∂schen

                this.addToTerminal('üõë Stoppe evtl. laufende Skripte (vor Hardware-Kontext-Laden)...\n');
                await this.sendRawCommand('\x03'); // Ctrl+C
                await new Promise(resolve => setTimeout(resolve, 50));
                await this.sendRawCommand('\r');   // Enter, um die REPL-Zeile zu s√§ubern
                await new Promise(resolve => setTimeout(resolve, 50));

                const loadHardwareCode = `
try:
    with open('hardware.txt', 'r') as f_hw:
        print('===HARDWARE_CONTEXT_START===')
        print(f_hw.read())
        print('===HARDWARE_CONTEXT_END===')
except Exception as e_hw:
    print('===HARDWARE_CONTEXT_START===') # Sende Marker, damit isLoadingHardwareContext zur√ºckgesetzt wird
    print(f"Fehler beim Lesen von hardware.txt: {e_hw}")
    print('===HARDWARE_CONTEXT_END===')
`;
                await this.sendRawCommand('\x05'); // Paste-Modus
                await new Promise(resolve => setTimeout(resolve, 50));
                await this.sendRawCommand(loadHardwareCode.replace(/\n/g, '\r') + '\r');
                await this.sendRawCommand('\x04'); // Ausf√ºhren
                await new Promise(resolve => setTimeout(resolve, 50)); // Kurze Pause
                await this.sendRawCommand('\r'); // REPL-Zeile s√§ubern
                // Das Ergebnis wird in startReading() verarbeitet
            }

            async _executeDeviceCommand(command, successMessage, errorMessagePrefix) {
                if (!this.isConnected) return;

                this.addToTerminal('üõë Stoppe evtl. laufende Skripte (vor Ger√§tebefehl)...\n');
                await this.sendRawCommand('\x03'); // Ctrl+C
                await new Promise(resolve => setTimeout(resolve, 50));
                await this.sendRawCommand('\r');   // Enter, um die REPL-Zeile zu s√§ubern
                await new Promise(resolve => setTimeout(resolve, 50));

                this.addToTerminal(`\n‚öôÔ∏è F√ºhre aus: ${command.splitlines ? command.splitlines()[0] : command}\n`); // Zeige nur die erste Zeile bei mehrzeiligen Befehlen
                
                const script = `
try:
    import os
    ${command}
    print("===CMD_SUCCESS===")
except Exception as e:
    print(f"===CMD_ERROR===:{e}")
`;
                await this.sendRawCommand('\x05'); // Paste-Modus starten
                await new Promise(resolve => setTimeout(resolve, 50));
                await this.sendRawCommand(script.replace(/\n/g, '\r') + '\r');
                await this.sendRawCommand('\x04'); // Paste-Modus beenden und ausf√ºhren
                await new Promise(resolve => setTimeout(resolve, 50)); // Kurze Pause
                await this.sendRawCommand('\r'); // REPL-Zeile s√§ubern
                await new Promise(resolve => setTimeout(resolve, 150)); // Restliche Wartezeit, falls f√ºr Befehlsausf√ºhrung ben√∂tigt

                // Hier k√∂nnte man auf ===CMD_SUCCESS=== oder ===CMD_ERROR=== in der Terminalausgabe lauschen,
                // aber f√ºr den Moment verlassen wir uns auf die Terminalausgabe und aktualisieren die Dateiliste.
                // Eine robustere L√∂sung w√ºrde eine Callback-Mechanik oder Promises verwenden, die auf die Marker warten.
                if (successMessage) this.addToTerminal(`\n‚úÖ ${successMessage}\n`);
                this.listFiles(); // Dateiliste immer aktualisieren
            }

            promptDeleteFile(filename) {
                if (confirm(`M√∂chten Sie die Datei '${filename}' wirklich l√∂schen?`)) {
                    this._executeDeviceCommand(`os.remove('${filename}')`, `Datei '${filename}' gel√∂scht.`);
                }
            }

            promptRenameFile(oldFilename) {
                const newFilename = prompt(`Neuen Namen f√ºr '${oldFilename}' eingeben:`, oldFilename);
                if (newFilename && newFilename !== oldFilename) {
                    if (!newFilename.endsWith('.py') && !newFilename.endsWith('.txt')) {
                         alert('Dateiname muss mit .py oder .txt enden.');
                         return;
                    }
                    this._executeDeviceCommand(`os.rename('${oldFilename}', '${newFilename}')`, `Datei '${oldFilename}' umbenannt in '${newFilename}'.`);
                    if (this.currentFile === oldFilename) {
                        this.currentFile = newFilename;
                        this.updateActiveTab(newFilename);
                    }
                }
            }

            async toggleConnection() {
                if (this.isConnected) {
                    await this.disconnect();
                } else {
                    await this.connect();
                }
            }

            async connect() {
                try {
                    this.addToTerminal('üîå Verbinde mit ESP32...\n');
                    
                    this.port = await navigator.serial.requestPort();
                    await this.port.open({ baudRate: 115200 });

                    this.reader = this.port.readable.getReader();
                    this.writer = this.port.writable.getWriter();

                    this.isConnected = true;
                    this.updateUI();
                    
                    this.addToTerminal('‚úÖ Erfolgreich verbunden!\n');
                    
                    // Stoppe evtl. laufende Skripte und stelle sicher, dass die REPL bereit ist
                    this.addToTerminal('üõë Stoppe evtl. laufende Skripte (nach Verbindung)...\n');
                    await this.sendRawCommand('\x03'); // Ctrl+C (Stop)
                    await new Promise(resolve => setTimeout(resolve, 50));
                    await this.sendRawCommand('\r');   // Enter, um die REPL-Zeile zu s√§ubern
                    await new Promise(resolve => setTimeout(resolve, 50));
                                        
                    this.startReading();
                    
                } catch (error) {
                    this.addToTerminal(`‚ùå Verbindungsfehler: ${error.message}\n`);
                }
            }

            async disconnect() {
                try {
                    if (this.reader) {
                        await this.reader.cancel();
                        this.reader.releaseLock();
                    }
                    if (this.writer) {
                        this.writer.releaseLock();
                    }
                    if (this.port) {
                        await this.port.close();
                    }
                    
                    this.isConnected = false;
                    this.updateUI();
                    this.addToTerminal('üîå Verbindung getrennt\n');
                    
                } catch (error) {
                    this.addToTerminal(`‚ùå Fehler beim Trennen: ${error.message}\n`);
                }
            }

            async startReading() {
                try {
                    let buffer = '';
                    while (this.isConnected) {
                        const { value, done } = await this.reader.read();
                        if (done) break;
                        
                        const text = new TextDecoder().decode(value);
                        this.addToTerminal(text);
                        
                        // Check for file list output
                        buffer += text;
                        if (buffer.includes('===FILELIST_END===')) {
                            const files = this.parseFileList(buffer);
                            if (files) {
                                this.updateFileBrowser(files);
                            }
                            buffer = '';
                        }
                        
                        // Check for file content output for editor
                        if (buffer.includes('===FILE_CONTENT_END===')) {
                            if (!this.isLoadingHardwareContext) { // Nur verarbeiten, wenn nicht Hardware-Kontext geladen wird
                                const content = this.parseFileContent(buffer);
                                if (content) {
                                    this.editor.setValue(content);
                                    this.files[this.currentFile] = content;
                                }
                            }
                            buffer = ''; // Buffer immer leeren, wenn End-Marker gefunden
                        }

                        // Check for hardware.txt content
                        if (buffer.includes('===HARDWARE_CONTEXT_END===')) {
                            if (this.isLoadingHardwareContext) {
                                const contextContent = this.parseHardwareContext(buffer);
                                if (contextContent !== null) {
                                    this.hardwareContext = contextContent;
                                    this.addToTerminal('\n‚úÖ Hardware-Kontext (hardware.txt) geladen.\n');
                                } else {
                                    this.addToTerminal('\n‚ö†Ô∏è Hardware-Kontext (hardware.txt) konnte nicht vollst√§ndig gelesen werden.\n');
                                }
                                this.isLoadingHardwareContext = false;
                            }
                            buffer = ''; // Buffer immer leeren
                        }
                    }
                } catch (error) {
                    if (this.isConnected) {
                        this.addToTerminal(`‚ùå Lesefehler: ${error.message}\n`);
                    }
                }
            }

            async sendRawCommand(command) {
                if (!this.writer) return;
                
                const encoder = new TextEncoder();
                await this.writer.write(encoder.encode(command));
            }

            async sendCommand() {
                const input = document.getElementById('terminalInput');
                const command = input.value;
                
                if (!command.trim()) return;
                
                this.addToTerminal(`>>> ${command}\n`);
                await this.sendRawCommand(command + '\r\n');
                
                input.value = '';
            }

            async runCode() {
                if (!this.isConnected) return;
                
                if (!this.currentFile) {
                    this.addToTerminal('\n‚ùå Bitte erst eine Datei hochladen\n');
                    return;
                }
                
                this.addToTerminal(`\n=== F√ºhre ${this.currentFile} aus ===\n`);

                this.addToTerminal('üõë Stoppe evtl. laufende Skripte (vor Code-Ausf√ºhrung)...\n');
                await this.sendRawCommand('\x03'); // Ctrl+C
                await new Promise(resolve => setTimeout(resolve, 50));
                await this.sendRawCommand('\r');   // Enter, um die REPL-Zeile zu s√§ubern
                await new Promise(resolve => setTimeout(resolve, 50));
                
                // Code ausf√ºhren mittels Paste-Modus und exec
                // await this.sendRawCommand('\r\n'); // Nicht mehr n√∂tig, da \r oben gesendet wurde

                // Construct the script with \r line endings for paste mode

                const pythonScriptSource = `try:
    with open('${this.currentFile}', 'r') as f:
        exec(f.read())
except OSError:
    print("Error: ${this.currentFile} not found")
except SyntaxError as e:
    print(f"SyntaxError in ${this.currentFile}: {e}")
`;
                const pythonScript = pythonScriptSource.replace(/\n/g, '\r') + '\r';                

                await this.sendRawCommand('\x05'); // Ctrl-E: Paste-Modus starten
                await new Promise(resolve => setTimeout(resolve, 100)); // Kurze Pause
                
                await this.sendRawCommand(pythonScript); // pythonScript hat bereits \r Endungen
                // Keine zus√§tzliche Pause hier, da der gesamte Block auf einmal gesendet wird
                
                await this.sendRawCommand('\x04'); // Ctrl-D: Paste-Modus beenden und ausf√ºhren
                await new Promise(resolve => setTimeout(resolve, 50)); // Kurze Pause danach
                await this.sendRawCommand('\r'); // REPL-Zeile s√§ubern
                await new Promise(resolve => setTimeout(resolve, 50)); 
            }

            async stopExecution() {
                if (!this.isConnected) return;
                
                this.addToTerminal('\nüõë Stoppe Ausf√ºhrung...\n');
                await this.sendRawCommand('\x03'); // Ctrl+C
            }

            async softReset() {
                if (!this.isConnected) return;
                
                this.addToTerminal('\nüîÑ Soft Reset...\n');
                await this.sendRawCommand('\x04'); // Ctrl+D
            }

            showUploadModal() {
                document.getElementById('filenameModal').style.display = 'block';
                document.getElementById('filenameInput').value = this.currentFile;
                document.getElementById('filenameInput').focus();
                // Fortschrittsbalken zur√ºcksetzen und ausblenden
                const progressBarContainer = document.getElementById('uploadProgressBarContainer');
                const progressBar = document.getElementById('uploadProgressBar');
                progressBar.style.width = '0%';
                progressBar.textContent = '';
                progressBarContainer.style.display = 'none';
            }

            async uploadFile() {
                const filename = document.getElementById('filenameInput').value;
                if (!filename) return;
                if (!filename.endsWith('.py') && !filename.endsWith('.txt')) {
                    this.addToTerminal('\n‚ùå Dateiname muss mit .py oder .txt enden\n');
                    return;
                }
                
                const code = this.editor.getValue();
                this.currentFile = filename;
                this.updateActiveTab(filename); // Tab aktualisieren
                const chunkSize = 200; // Noch kleinere Chunk-Gr√∂√üe
                const totalChunks = Math.ceil(code.length / chunkSize);

                const progressBarContainer = document.getElementById('uploadProgressBarContainer');
                const progressBar = document.getElementById('uploadProgressBar');
                progressBar.style.width = '0%';
                progressBar.textContent = '0%';
                progressBarContainer.style.display = 'block';
                
                this.addToTerminal(`\nüì§ Lade ${filename} hoch (${code.length} Zeichen, ${totalChunks} Teile)...\n`);
                this.addToTerminal('‚ö†Ô∏è Bitte warten w√§hrend die Datei hochgeladen wird...\n');
                
                try {
                    // Datei erstellen
                    await this.sendRawCommand('\x05');
                    await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                    await this.sendRawCommand(`f=open('${filename}','w')\r\n`);
                    await this.sendRawCommand('\x04');
                    await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                    
                    // Code in Chunks hochladen
                    for (let i = 0; i < totalChunks; i++) {
                        const chunk = code.substring(i * chunkSize, (i + 1) * chunkSize);
                        // Sonderzeichen escapen
                        const escapedChunk = chunk
                            .replace(/\\/g, '\\\\')
                            .replace(/'/g, "\\'")
                            .replace(/\r/g, '\\r')
                            .replace(/\n/g, '\\n');
                        
                        try {
                            await this.sendRawCommand('\x05');
                            await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                            await this.sendRawCommand(`f.write('${escapedChunk}')\r\n`);
                            await this.sendRawCommand('\x04');
                            await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                            
                            // Fortschritt anzeigen
                            const progress = Math.round(((i + 1) / totalChunks) * 100);
                            this.addToTerminal(`\rüîº Hochgeladen: ${progress}% (${(i + 1) * chunkSize}/${code.length})`);
                            progressBar.style.width = progress + '%';
                            progressBar.textContent = progress + '%';
                        } catch (error) {
                            this.addToTerminal(`\n‚ùå Fehler bei Chunk ${i+1}: ${error.message}\n`);
                            progressBarContainer.style.display = 'none'; // Fortschrittsbalken bei Fehler ausblenden
                            throw error;
                        }
                    }
                    
                    // Datei schlie√üen
                    await this.sendRawCommand('\x05');
                    await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                    await this.sendRawCommand('f.close()\r\n');
                    await this.sendRawCommand('\x04');
                    await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                    
                    this.addToTerminal(`\n‚úÖ ${filename} erfolgreich hochgeladen!\n`);
                    progressBar.textContent = '100%'; // Sicherstellen, dass es 100% anzeigt
                    
                } catch (error) {
                    this.addToTerminal(`\n‚ùå Fehler beim Hochladen: ${error.message}\n`);
                    progressBarContainer.style.display = 'none'; // Fortschrittsbalken bei Fehler ausblenden
                } finally {
                    // Kurze Verz√∂gerung, bevor das Modal geschlossen wird, damit der Benutzer 100% sieht
                    setTimeout(() => {
                        closeModal();
                        // Fortschrittsbalken f√ºr das n√§chste Mal ausblenden (wird auch in showUploadModal gemacht, aber sicher ist sicher)
                        progressBarContainer.style.display = 'none';
                        progressBar.style.width = '0%';
                        progressBar.textContent = '';
                    }, 500);
                    setTimeout(() => this.listFiles(), 1000); // listFiles nach dem Schlie√üen des Modals
                }
            }

            async loadFile(filename) {
                if (!this.isConnected) return;

                this.addToTerminal('üõë Stoppe evtl. laufende Skripte (vor Datei-Laden)...\n');
                await this.sendRawCommand('\x03'); // Ctrl+C
                await new Promise(resolve => setTimeout(resolve, 50));
                await this.sendRawCommand('\r');   // Enter, um die REPL-Zeile zu s√§ubern
                await new Promise(resolve => setTimeout(resolve, 50));
                
                this.addToTerminal(`\nüì• Lade ${filename}...\n`);
                
                const loadCode = `
try:
    with open('${filename}', 'r') as f:
        print('===FILE_CONTENT_START===')
        print(f.read())
        print('===FILE_CONTENT_END===')
except Exception as e:
    print('Fehler:', e)
`;
                
                await this.sendRawCommand('\x05');
                await new Promise(resolve => setTimeout(resolve, 100));
                await this.sendRawCommand(loadCode.replace(/\n/g, '\r') + '\r'); // Korrektur und korrekte Zeilenenden
                await this.sendRawCommand('\x04');
                await new Promise(resolve => setTimeout(resolve, 50)); // Kurze Pause
                await this.sendRawCommand('\r'); // REPL-Zeile s√§ubern
                
                // Datei im Editor anzeigen
                this.currentFile = filename;
                this.updateActiveTab(filename); // Tab aktualisieren
                this.editor.setValue(''); // Inhalt wird durch Lesevorgang gef√ºllt
            }

            parseFileContent(text) {
                const startMarker = '===FILE_CONTENT_START===';
                const endMarker = '===FILE_CONTENT_END===';
                
                const start = text.indexOf(startMarker);
                const end = text.indexOf(endMarker);
                
                if (start === -1 || end === -1) return null;
                
                let content = text.substring(start + startMarker.length, end);
                // Normalisiere Zeilenenden (CRLF -> LF)
                content = content.replace(/\r\n/g, '\n');
                // Entferne √ºberfl√ºssige Leerzeilen am Anfang und Ende
                content = content.replace(/^\n+|\n+$/g, '');
                return content;
            }

            parseHardwareContext(text) {
                const startMarker = '===HARDWARE_CONTEXT_START===';
                const endMarker = '===HARDWARE_CONTEXT_END===';
                
                const start = text.indexOf(startMarker);
                const end = text.indexOf(endMarker);
                
                if (start === -1 || end === -1) return null; // Nicht vollst√§ndig
                
                let content = text.substring(start + startMarker.length, end);
                content = content.replace(/\r\n/g, '\n').trim(); // Normalisieren und trimmen
                
                // Pr√ºfen, ob ein Fehler beim Lesen gemeldet wurde
                if (content.startsWith("Fehler beim Lesen von hardware.txt:")) {
                    this.addToTerminal(`\n‚ö†Ô∏è ${content}\n`); // Fehler im Terminal anzeigen
                    return ''; // Leeren Kontext zur√ºckgeben, da Datei nicht lesbar war
                }
                return content;
            }

            async listFiles() {
                if (!this.isConnected) return;

                this.addToTerminal('üõë Stoppe evtl. laufende Skripte (vor Dateiliste)...\n');
                await this.sendRawCommand('\x03'); // Ctrl+C
                await new Promise(resolve => setTimeout(resolve, 50));
                await this.sendRawCommand('\r');   // Enter, um die REPL-Zeile zu s√§ubern
                await new Promise(resolve => setTimeout(resolve, 50));
                
                this.addToTerminal('\nüìÅ Dateien werden aufgelistet...\n');
                
                const listCode = `
import os
print('===FILELIST_START===')
for file in os.listdir():
    try:
        stat = os.stat(file)
        size = stat[6]
        print(f'{file}|{size}')
    except:
        print(f'{file}|folder')
print('===FILELIST_END===')
`;
                
                await this.sendRawCommand('\x05');
                await new Promise(resolve => setTimeout(resolve, 100));
                await this.sendRawCommand(listCode.replace(/\n/g, '\r') + '\r'); // Korrekte Zeilenenden f√ºr Paste-Modus
                await this.sendRawCommand('\x04');
                await new Promise(resolve => setTimeout(resolve, 50)); // Kurze Pause
                await this.sendRawCommand('\r'); // REPL-Zeile s√§ubern
            }

            parseFileList(text) {
                const startMarker = '===FILELIST_START===';
                const endMarker = '===FILELIST_END===';
                
                const start = text.indexOf(startMarker);
                const end = text.indexOf(endMarker);
                
                if (start === -1 || end === -1) return null;
                
                const fileListText = text.substring(start + startMarker.length, end).trim();
                const lines = fileListText.split('\n');
                
                const files = [];
                for (const line of lines) {
                    const [name, size] = line.split('|');
                    files.push({name, size});
                }
                
                return files;
            }

            updateFileBrowser(files) {
                this.deviceFiles = files.map(f => f.name); // Aktuelle Dateinamen speichern
                
                // Pr√ºfen, ob hardware.txt vorhanden ist und eine Datei ist, dann laden/aktualisieren
                const hardwareTxtEntry = files.find(f => f.name === 'hardware.txt');
                if (hardwareTxtEntry && hardwareTxtEntry.size !== 'folder') {
                    this.fetchHardwareContextFile();
                } else {
                    if (this.hardwareContext) { // hardware.txt nicht (als Datei) gefunden, Kontext l√∂schen
                        this.hardwareContext = '';
                        if (hardwareTxtEntry && hardwareTxtEntry.size === 'folder') {
                            this.addToTerminal('\n‚ÑπÔ∏è Hardware-Kontext (hardware.txt) ist ein Ordner und wird nicht geladen.\n');
                        } else {
                            this.addToTerminal('\n‚ÑπÔ∏è Hardware-Kontext (hardware.txt) nicht als Datei gefunden oder entfernt.\n');
                        }
                    }
                }

                const fileListElement = document.getElementById('fileList');
                const contextMenu = document.getElementById('fileContextMenu');
                fileListElement.innerHTML = '';
                
                files.forEach(file => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.textContent = `${file.name} (${file.size === 'folder' ? 'Ordner' : file.size + ' bytes'})`;
                    
                    fileItem.addEventListener('click', () => {
                        contextMenu.style.display = 'none'; // Kontextmen√º ausblenden, falls offen
                        this.loadFile(file.name);
                    });

                    fileItem.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        this.contextMenuTargetFile = file.name;
                        contextMenu.style.left = `${e.clientX}px`;
                        contextMenu.style.top = `${e.clientY}px`;
                        contextMenu.style.display = 'block';
                    });
                    fileListElement.appendChild(fileItem);
                });
            }

            addToTerminal(text) {
                const terminal = document.getElementById('terminal');
                terminal.textContent += text;
                terminal.scrollTop = terminal.scrollHeight;
            }

            clearTerminal() {
                document.getElementById('terminal').textContent = '';
            }

            updateUI() {
                const connectBtn = document.getElementById('connectBtn');
                const status = document.getElementById('status');
                // 'newFileBtn' wird hier nicht mehr aufgef√ºhrt, da er immer aktiv sein soll.
                // 'uploadBtn' wird separat behandelt (z.B. in newFile oder wenn eine Datei geladen wird).
                const buttonsToToggle = ['runBtn', 'stopBtn', 'listFilesBtn', 'softResetBtn'];
                const terminalInput = document.getElementById('terminalInput');
                
                if (this.isConnected) {
                    connectBtn.textContent = 'Trennen';
                    status.textContent = 'Verbunden';
                    status.className = 'status connected';
                    buttonsToToggle.forEach(id => document.getElementById(id).disabled = false);
                    document.getElementById('uploadBtn').disabled = false; // Generell Upload erlauben wenn verbunden
                    terminalInput.disabled = false;
                } else {
                    connectBtn.textContent = 'Mit ESP32 verbinden';
                    status.textContent = 'Nicht verbunden';
                    status.className = 'status disconnected';
                    buttonsToToggle.forEach(id => document.getElementById(id).disabled = true);
                    document.getElementById('uploadBtn').disabled = true; // Upload nur wenn verbunden
                    terminalInput.disabled = true;
                }
            }
        }

        function closeModal() {
            document.getElementById('filenameModal').style.display = 'none';
        }

        // Monaco Editor initialisieren
        function initEditor() {
            try {
                require(['vs/editor/editor.main'], function() {
                    const editor = monaco.editor.create(document.getElementById('editor'), {
                        value: [
                            "# Dein MicroPython Code hier...",
                            "print('Hello ESP32!')",
                            "",
                            "# Beispiel: LED blinken",
                            "from machine import Pin",
                            "import time",
                            "",
                            "led = Pin(2, Pin.OUT)  # GPIO 2 f√ºr eingebaute LED",
                            "",
                            "for i in range(10):",
                            "    led.on()",
                            "    time.sleep(0.5)",
                            "    led.off()",
                            "    time.sleep(0.5)",
                            "    print('Blink ' + str(i + 1))  # f-string removed for wider compatibility"
                        ].join('\n'),
                        language: 'python',
                        theme: 'vs-dark',
                        automaticLayout: true,
                        minimap: { enabled: false },
                        fontSize: 14,
                        lineNumbers: 'on',
                        roundedSelection: true,
                        scrollBeyondLastLine: false,
                        renderWhitespace: 'selection',
                        tabSize: 4
                    });

                    // IDE initialisieren und Editor √ºbergeben
                    window.ide = new MicroPythonIDE(editor);
                });
            } catch (error) {
                console.error('Editor Initialization Error:', error);
                // Fallback falls Monaco nicht l√§dt
                const editorElement = document.getElementById('editor');
                editorElement.innerHTML = '<textarea style="width:100%;height:100%;background:#1e1e1e;color:#d4d4d4;border:none;padding:10px;font-family:monospace;font-size:14px;" id="fallbackEditor"># Dein MicroPython Code hier...\nprint(\'Hello ESP32!\')</textarea>';
                window.ide = new MicroPythonIDE({
                    getValue: () => document.getElementById('fallbackEditor').value,
                    setValue: (content) => document.getElementById('fallbackEditor').value = content,
                    onDidChangeModelContent: (callback) => {
                        document.getElementById('fallbackEditor').addEventListener('input', callback);
                    }
                });
            }
        }

        // Editor laden wenn alles fertig ist
        if (document.readyState === 'complete') {
            initEditor();
        } else {
            window.addEventListener('load', initEditor);
        }
    </script>

    <div id="fileContextMenu" class="context-menu" style="display: none; position: absolute; background-color: #3c3c3c; border: 1px solid #555; padding: 5px 0; z-index: 1001; border-radius: 4px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
        <div class="context-menu-item" data-action="rename">Umbenennen</div>
        <div class="context-menu-item" data-action="delete">L√∂schen</div>
    </div>
</body>
</html>
