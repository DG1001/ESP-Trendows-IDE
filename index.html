<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MicroPython Web IDE</title>
    <!-- Monaco Editor -->
    <link rel="stylesheet" data-name="vs/editor/editor.main" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/editor/editor.main.min.css">
    <script>
        var require = { paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs' } };
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/loader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/editor/editor.main.nls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/editor/editor.main.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            background: #2d2d30;
            padding: 10px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .btn {
            background: #0e639c;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #1177bb;
        }

        .btn:disabled {
            background: #555;
            cursor: not-allowed;
        }

        .btn.danger {
            background: #d73a49;
        }

        .btn.danger:hover {
            background: #e85565;
        }

        .status {
            margin-left: auto;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .status.connected {
            background: #28a745;
        }

        .status.disconnected {
            background: #dc3545;
        }

        .main-content {
            display: flex;
            flex: 1;
            min-height: 0;
        }

        .editor-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #3e3e42;
        }

        .file-tabs {
            background: #2d2d30;
            padding: 0;
            border-bottom: 1px solid #3e3e42;
            display: flex;
        }

        .tab {
            background: #3c3c3c;
            border: none;
            color: #d4d4d4;
            padding: 8px 16px;
            cursor: pointer;
            border-right: 1px solid #3e3e42;
            font-size: 12px;
        }

        .tab.active {
            background: #1e1e1e;
        }

        #editor-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .terminal-panel {
            width: 40%;
            display: flex;
            flex-direction: column;
            background: #0c0c0c;
        }

        .terminal-header {
            background: #2d2d30;
            padding: 8px 12px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .terminal {
            flex: 1;
            background: #0c0c0c;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .terminal-input {
            background: #0c0c0c;
            border: none;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            outline: none;
            border-top: 1px solid #3e3e42;
        }

        .file-browser {
            width: 200px;
            background: #252526;
            border-right: 1px solid #3e3e42;
            padding: 10px;
            overflow-y: auto;
        }

        .file-item {
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
        }

        .file-item:hover {
            background: #2a2d2e;
        }

        .file-item.selected {
            background: #094771;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .modal-content {
            background: #2d2d30;
            margin: 15% auto;
            padding: 20px;
            border-radius: 8px;
            width: 300px;
            color: #d4d4d4;
        }

        .modal input {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            color: #d4d4d4;
            border-radius: 4px;
        }

        .spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #555;
            border-top: 2px solid #0e639c;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <button class="btn" id="connectBtn">Mit ESP32 verbinden</button>
        <button class="btn" id="runBtn" disabled>Ausführen (F5)</button>
        <button class="btn" id="stopBtn" disabled>Stopp</button>
        <button class="btn" id="uploadBtn" disabled>Hochladen</button>
        <button class="btn" id="listFilesBtn" disabled>Dateien auflisten</button>
        <button class="btn danger" id="softResetBtn" disabled>Soft Reset</button>
        <div class="status disconnected" id="status">Nicht verbunden</div>
    </div>

    <div class="main-content">
        <div class="file-browser">
            <h4 style="margin-bottom: 10px;">Dateien auf ESP32</h4>
            <div id="fileList"></div>
        </div>

        <div class="editor-panel">
            <div class="file-tabs">
                <button class="tab active" data-file="main.py">main.py</button>
            </div>
            <div id="editor-container">
                <div id="editor" style="height:100%"></div>
            </div>
        </div>

        <div class="terminal-panel">
            <div class="terminal-header">
                <span>REPL Terminal</span>
                <button class="btn" id="clearTerminalBtn">Löschen</button>
            </div>
            <div class="terminal" id="terminal">Bereit für Verbindung...\n</div>
            <input class="terminal-input" id="terminalInput" placeholder=">>> MicroPython Befehl eingeben..." disabled>
        </div>
    </div>

    <!-- Modal für Dateinamen -->
    <div class="modal" id="filenameModal">
        <div class="modal-content">
            <h3>Datei speichern als:</h3>
            <input type="text" id="filenameInput" placeholder="dateiname.py">
            <div style="margin-top: 15px;">
                <button class="btn" id="saveFileBtn">Speichern</button>
                <button class="btn" onclick="closeModal()">Abbrechen</button>
            </div>
        </div>
    </div>

    <script>
        class MicroPythonIDE {
            constructor(editor) {
                this.port = null;
                this.reader = null;
                this.writer = null;
                this.isConnected = false;
                this.currentFile = 'main.py';
                this.editor = editor;
                this.files = {'main.py': this.editor.getValue()};
                
                this.initializeEventListeners();
                this.checkWebSerialSupport();
            }

            checkWebSerialSupport() {
                if (!('serial' in navigator)) {
                    this.addToTerminal('❌ Web Serial API wird nicht unterstützt. Bitte verwende Chrome oder Edge.\n');
                }
            }

            initializeEventListeners() {
                document.getElementById('connectBtn').addEventListener('click', () => this.toggleConnection());
                document.getElementById('runBtn').addEventListener('click', () => this.runCode());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopExecution());
                document.getElementById('uploadBtn').addEventListener('click', () => this.showUploadModal());
                document.getElementById('listFilesBtn').addEventListener('click', () => this.listFiles());
                document.getElementById('softResetBtn').addEventListener('click', () => this.softReset());
                document.getElementById('clearTerminalBtn').addEventListener('click', () => this.clearTerminal());
                document.getElementById('terminalInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendCommand();
                });
                document.getElementById('saveFileBtn').addEventListener('click', () => this.uploadFile());

                // F5 für Ausführen
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'F5') {
                        e.preventDefault();
                        if (this.isConnected) this.runCode();
                    }
                });

                // Editor Änderungen speichern
                this.editor.onDidChangeModelContent(() => {
                    this.files[this.currentFile] = this.editor.getValue();
                });
            }

            async toggleConnection() {
                if (this.isConnected) {
                    await this.disconnect();
                } else {
                    await this.connect();
                }
            }

            async connect() {
                try {
                    this.addToTerminal('🔌 Verbinde mit ESP32...\n');
                    
                    this.port = await navigator.serial.requestPort();
                    await this.port.open({ baudRate: 115200 });

                    this.reader = this.port.readable.getReader();
                    this.writer = this.port.writable.getWriter();

                    this.isConnected = true;
                    this.updateUI();
                    
                    this.addToTerminal('✅ Erfolgreich verbunden!\n');
                    
                    // REPL starten
                    await this.sendRawCommand('\x03\x03\x02'); // Ctrl+C, Ctrl+C, Ctrl+B
                    
                    this.startReading();
                    
                } catch (error) {
                    this.addToTerminal(`❌ Verbindungsfehler: ${error.message}\n`);
                }
            }

            async disconnect() {
                try {
                    if (this.reader) {
                        await this.reader.cancel();
                        this.reader.releaseLock();
                    }
                    if (this.writer) {
                        this.writer.releaseLock();
                    }
                    if (this.port) {
                        await this.port.close();
                    }
                    
                    this.isConnected = false;
                    this.updateUI();
                    this.addToTerminal('🔌 Verbindung getrennt\n');
                    
                } catch (error) {
                    this.addToTerminal(`❌ Fehler beim Trennen: ${error.message}\n`);
                }
            }

            async startReading() {
                try {
                    let buffer = '';
                    while (this.isConnected) {
                        const { value, done } = await this.reader.read();
                        if (done) break;
                        
                        const text = new TextDecoder().decode(value);
                        this.addToTerminal(text);
                        
                        // Check for file list output
                        buffer += text;
                        if (buffer.includes('===FILELIST_END===')) {
                            const files = this.parseFileList(buffer);
                            if (files) {
                                this.updateFileBrowser(files);
                            }
                            buffer = '';
                        }
                        
                        // Check for file content output
                        if (buffer.includes('===FILE_CONTENT_END===')) {
                            const content = this.parseFileContent(buffer);
                            if (content) {
                                this.editor.setValue(content);
                                this.files[this.currentFile] = content;
                            }
                            buffer = '';
                        }
                    }
                } catch (error) {
                    if (this.isConnected) {
                        this.addToTerminal(`❌ Lesefehler: ${error.message}\n`);
                    }
                }
            }

            async sendRawCommand(command) {
                if (!this.writer) return;
                
                const encoder = new TextEncoder();
                await this.writer.write(encoder.encode(command));
            }

            async sendCommand() {
                const input = document.getElementById('terminalInput');
                const command = input.value;
                
                if (!command.trim()) return;
                
                this.addToTerminal(`>>> ${command}\n`);
                await this.sendRawCommand(command + '\r\n');
                
                input.value = '';
            }

            async runCode() {
                if (!this.isConnected) return;
                
                const code = this.editor.getValue();
                this.addToTerminal('\n=== Code wird ausgeführt ===\n');
                
                // Paste-Modus für mehrzeiligen Code
                await this.sendRawCommand('\x05'); // Ctrl+E (paste mode)
                await new Promise(resolve => setTimeout(resolve, 100));
                await this.sendRawCommand(code);
                await this.sendRawCommand('\x04'); // Ctrl+D (execute)
            }

            async stopExecution() {
                if (!this.isConnected) return;
                
                this.addToTerminal('\n🛑 Stoppe Ausführung...\n');
                await this.sendRawCommand('\x03'); // Ctrl+C
            }

            async softReset() {
                if (!this.isConnected) return;
                
                this.addToTerminal('\n🔄 Soft Reset...\n');
                await this.sendRawCommand('\x04'); // Ctrl+D
            }

            showUploadModal() {
                document.getElementById('filenameModal').style.display = 'block';
                document.getElementById('filenameInput').value = this.currentFile;
                document.getElementById('filenameInput').focus();
            }

            async uploadFile() {
                const filename = document.getElementById('filenameInput').value;
                if (!filename) return;
                
                const code = this.editor.getValue();
                const chunkSize = 200; // Noch kleinere Chunk-Größe
                const totalChunks = Math.ceil(code.length / chunkSize);
                
                this.addToTerminal(`\n📤 Lade ${filename} hoch (${code.length} Zeichen, ${totalChunks} Teile)...\n`);
                this.addToTerminal('⚠️ Bitte warten während die Datei hochgeladen wird...\n');
                
                try {
                    // Datei erstellen
                    await this.sendRawCommand('\x05');
                    await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                    await this.sendRawCommand(`f=open('${filename}','w')\r\n`);
                    await this.sendRawCommand('\x04');
                    await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                    
                    // Code in Chunks hochladen
                    for (let i = 0; i < totalChunks; i++) {
                        const chunk = code.substring(i * chunkSize, (i + 1) * chunkSize);
                        // Sonderzeichen escapen
                        const escapedChunk = chunk
                            .replace(/\\/g, '\\\\')
                            .replace(/'/g, "\\'")
                            .replace(/\r/g, '\\r')
                            .replace(/\n/g, '\\n');
                        
                        try {
                            await this.sendRawCommand('\x05');
                            await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                            await this.sendRawCommand(`f.write('${escapedChunk}')\r\n`);
                            await this.sendRawCommand('\x04');
                            await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                            
                            // Fortschritt anzeigen
                            const progress = Math.round(((i + 1) / totalChunks) * 100);
                            this.addToTerminal(`\r🔼 Hochgeladen: ${progress}% (${(i + 1) * chunkSize}/${code.length})`);
                        } catch (error) {
                            this.addToTerminal(`\n❌ Fehler bei Chunk ${i+1}: ${error.message}\n`);
                            throw error;
                        }
                    }
                    
                    // Datei schließen
                    await this.sendRawCommand('\x05');
                    await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                    await this.sendRawCommand('f.close()\r\n');
                    await this.sendRawCommand('\x04');
                    await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                    
                    this.addToTerminal(`\n✅ ${filename} erfolgreich hochgeladen!\n`);
                    
                } catch (error) {
                    this.addToTerminal(`\n❌ Fehler beim Hochladen: ${error.message}\n`);
                } finally {
                    closeModal();
                    setTimeout(() => this.listFiles(), 1000);
                }
            }

            async loadFile(filename) {
                if (!this.isConnected) return;
                
                this.addToTerminal(`\n📥 Lade ${filename}...\n`);
                
                const loadCode = `
try:
    with open('${filename}', 'r') as f:
        print('===FILE_CONTENT_START===')
        print(f.read())
        print('===FILE_CONTENT_END===')
except Exception as e:
    print('Fehler:', e)
`;
                
                await this.sendRawCommand('\x05');
                await new Promise(resolve => setTimeout(resolve, 100));
                await this.sendRawCommand(loadCode);
                await this.sendRawCommand('\x04');
                
                // Datei im Editor anzeigen
                this.currentFile = filename;
                this.editor.setValue('');
            }

            parseFileContent(text) {
                const startMarker = '===FILE_CONTENT_START===';
                const endMarker = '===FILE_CONTENT_END===';
                
                const start = text.indexOf(startMarker);
                const end = text.indexOf(endMarker);
                
                if (start === -1 || end === -1) return null;
                
                let content = text.substring(start + startMarker.length, end);
                // Normalisiere Zeilenenden (CRLF -> LF)
                content = content.replace(/\r\n/g, '\n');
                // Entferne überflüssige Leerzeilen am Anfang und Ende
                content = content.replace(/^\n+|\n+$/g, '');
                return content;
            }

            async listFiles() {
                if (!this.isConnected) return;
                
                this.addToTerminal('\n📁 Dateien werden aufgelistet...\n');
                
                const listCode = `
import os
print('===FILELIST_START===')
for file in os.listdir():
    try:
        stat = os.stat(file)
        size = stat[6]
        print(f'{file}|{size}')
    except:
        print(f'{file}|folder')
print('===FILELIST_END===')
`;
                
                await this.sendRawCommand('\x05');
                await new Promise(resolve => setTimeout(resolve, 100));
                await this.sendRawCommand(listCode);
                await this.sendRawCommand('\x04');
            }

            parseFileList(text) {
                const startMarker = '===FILELIST_START===';
                const endMarker = '===FILELIST_END===';
                
                const start = text.indexOf(startMarker);
                const end = text.indexOf(endMarker);
                
                if (start === -1 || end === -1) return null;
                
                const fileListText = text.substring(start + startMarker.length, end).trim();
                const lines = fileListText.split('\n');
                
                const files = [];
                for (const line of lines) {
                    const [name, size] = line.split('|');
                    files.push({name, size});
                }
                
                return files;
            }

            updateFileBrowser(files) {
                const fileListElement = document.getElementById('fileList');
                fileListElement.innerHTML = '';
                
                files.forEach(file => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.textContent = `${file.name} (${file.size === 'folder' ? 'Ordner' : file.size + ' bytes'})`;
                    fileItem.addEventListener('click', () => this.loadFile(file.name));
                    fileListElement.appendChild(fileItem);
                });
            }

            addToTerminal(text) {
                const terminal = document.getElementById('terminal');
                terminal.textContent += text;
                terminal.scrollTop = terminal.scrollHeight;
            }

            clearTerminal() {
                document.getElementById('terminal').textContent = '';
            }

            updateUI() {
                const connectBtn = document.getElementById('connectBtn');
                const status = document.getElementById('status');
                const buttons = ['runBtn', 'stopBtn', 'uploadBtn', 'listFilesBtn', 'softResetBtn'];
                const terminalInput = document.getElementById('terminalInput');
                
                if (this.isConnected) {
                    connectBtn.textContent = 'Trennen';
                    status.textContent = 'Verbunden';
                    status.className = 'status connected';
                    buttons.forEach(id => document.getElementById(id).disabled = false);
                    terminalInput.disabled = false;
                } else {
                    connectBtn.textContent = 'Mit ESP32 verbinden';
                    status.textContent = 'Nicht verbunden';
                    status.className = 'status disconnected';
                    buttons.forEach(id => document.getElementById(id).disabled = true);
                    terminalInput.disabled = true;
                }
            }
        }

        function closeModal() {
            document.getElementById('filenameModal').style.display = 'none';
        }

        // Monaco Editor initialisieren
        function initEditor() {
            try {
                require(['vs/editor/editor.main'], function() {
                    const editor = monaco.editor.create(document.getElementById('editor'), {
                        value: [
                            "# Dein MicroPython Code hier...",
                            "print('Hello ESP32!')",
                            "",
                            "# Beispiel: LED blinken",
                            "from machine import Pin",
                            "import time",
                            "",
                            "led = Pin(2, Pin.OUT)  # GPIO 2 für eingebaute LED",
                            "",
                            "for i in range(10):",
                            "    led.on()",
                            "    time.sleep(0.5)",
                            "    led.off()",
                            "    time.sleep(0.5)",
                            "    print(f'Blink {i+1}')"
                        ].join('\n'),
                        language: 'python',
                        theme: 'vs-dark',
                        automaticLayout: true,
                        minimap: { enabled: false },
                        fontSize: 14,
                        lineNumbers: 'on',
                        roundedSelection: true,
                        scrollBeyondLastLine: false,
                        renderWhitespace: 'selection',
                        tabSize: 4
                    });

                    // IDE initialisieren und Editor übergeben
                    window.ide = new MicroPythonIDE(editor);
                });
            } catch (error) {
                console.error('Editor Initialization Error:', error);
                // Fallback falls Monaco nicht lädt
                const editorElement = document.getElementById('editor');
                editorElement.innerHTML = '<textarea style="width:100%;height:100%;background:#1e1e1e;color:#d4d4d4;border:none;padding:10px;font-family:monospace;font-size:14px;" id="fallbackEditor"># Dein MicroPython Code hier...\nprint(\'Hello ESP32!\')</textarea>';
                window.ide = new MicroPythonIDE({
                    getValue: () => document.getElementById('fallbackEditor').value,
                    setValue: (content) => document.getElementById('fallbackEditor').value = content,
                    onDidChangeModelContent: (callback) => {
                        document.getElementById('fallbackEditor').addEventListener('input', callback);
                    }
                });
            }
        }

        // Editor laden wenn alles fertig ist
        if (document.readyState === 'complete') {
            initEditor();
        } else {
            window.addEventListener('load', initEditor);
        }
    </script>
</body>
</html>
