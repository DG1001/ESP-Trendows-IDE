<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MicroPython Web IDE</title>
    <!-- Monaco Editor -->
    <link rel="stylesheet" data-name="vs/editor/editor.main" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/editor/editor.main.min.css">
    <script>
        var require = { paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs' } };
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/loader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/editor/editor.main.nls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/editor/editor.main.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            background: #2d2d30;
            padding: 10px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .btn {
            background: #0e639c;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #1177bb;
        }

        .btn:disabled {
            background: #555;
            cursor: not-allowed;
        }

        .btn.danger {
            background: #d73a49;
        }

        .btn.danger:hover {
            background: #e85565;
        }

        .status {
            margin-left: auto;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .status.connected {
            background: #28a745;
        }

        .status.disconnected {
            background: #dc3545;
        }

        .main-content {
            display: flex;
            flex: 1;
            min-height: 0;
        }

        .editor-panel {
            flex: 1; /* Nimmt verfügbaren Platz ein */
            display: flex;
            flex-direction: column;
            min-width: 200px; /* Mindestbreite für den Editor */
        }

        #resizerVertical {
            width: 5px;
            background-color: #3e3e42;
            cursor: col-resize;
            flex-shrink: 0; /* Verhindert, dass der Resizer schrumpft */
        }

        .file-tabs {
            background: #2d2d30;
            padding: 0;
            border-bottom: 1px solid #3e3e42;
            display: flex;
        }

        .tab {
            background: #3c3c3c;
            border: none;
            color: #d4d4d4;
            padding: 8px 16px;
            cursor: pointer;
            border-right: 1px solid #3e3e42;
            font-size: 12px;
        }

        .tab.active {
            background: #1e1e1e;
        }

        #editor-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .terminal-panel {
            /* width: 40%; wird durch flex-basis ersetzt */
            flex: 0 0 40%; /* Nicht wachsen, nicht schrumpfen, Basisbreite 40% */
            display: flex;
            flex-direction: column;
            min-width: 150px; /* Mindestbreite für das Terminal */
            background: #0c0c0c;
        }

        .terminal-header {
            background: #2d2d30;
            padding: 8px 12px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .terminal {
            flex: 1;
            background: #0c0c0c;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .terminal-input {
            background: #0c0c0c;
            border: none;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            outline: none;
            border-top: 1px solid #3e3e42;
        }

        .file-browser {
            width: 200px;
            flex-shrink: 0; /* Verhindert, dass der File-Browser schrumpft */
            background: #252526;
            border-right: 1px solid #3e3e42;
            padding: 10px;
            overflow-y: auto;
        }

        .file-item {
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
        }

        .file-item:hover {
            background: #2a2d2e;
        }

        .file-item.selected {
            background: #094771;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .modal-content {
            background: #2d2d30;
            margin: 15% auto;
            padding: 20px;
            border-radius: 8px;
            width: 300px;
            color: #d4d4d4;
        }

        .modal input {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            color: #d4d4d4;
            border-radius: 4px;
        }

        .spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #555;
            border-top: 2px solid #0e639c;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .prompt-panel {
            display: flex;
            padding: 10px;
            background: #2d2d30;
            border-top: 1px solid #3e3e42;
        }

        .prompt-panel input {
            flex-grow: 1;
            padding: 8px;
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            color: #d4d4d4;
            border-radius: 4px;
            font-size: 12px;
            margin-right: 10px;
        }

        .context-menu-item {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 12px;
            color: #d4d4d4;
        }
        .context-menu-item:hover {
            background-color: #0e639c;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <button class="btn" id="connectBtn">Mit ESP32 verbinden</button>
        <button class="btn" id="newFileBtn">Neu</button> 
        <button class="btn" id="runBtn" disabled>Ausführen (F5)</button>
        <button class="btn" id="stopBtn" disabled>Stopp</button>
        <button class="btn" id="uploadBtn" disabled>Hochladen</button> <!-- Bleibt initial disabled -->
        <button class="btn" id="listFilesBtn" disabled>Dateien auflisten</button>
        <button class="btn danger" id="softResetBtn" disabled>Soft Reset</button>
        <input type="password" id="deepSeekApiKeyInput" placeholder="DeepSeek API Key" style="margin-left: 10px; padding: 8px; background: #1e1e1e; border: 1px solid #3e3e42; color: #d4d4d4; border-radius: 4px; font-size: 12px; min-width: 150px;">
        <div id="llmUsageStats" style="margin-left: 10px; font-size: 10px; display: flex; gap: 8px; align-items: center;">
            <span>P: <span id="promptTokens">0</span></span>
            <span>C: <span id="completionTokens">0</span></span>
            <span>T: <span id="totalTokens">0</span></span>
            <span>Cost: <span id="lastCost">0.00</span>µ</span>
            <span>Total: <span id="totalSessionCost">0.00</span>µ</span>
        </div>
        <div class="status disconnected" id="status">Nicht verbunden</div>
    </div>

    <div class="main-content">
        <div class="file-browser">
            <h4 style="margin-bottom: 10px;">Dateien auf ESP32</h4>
            <div id="fileList"></div>
        </div>

        <div class="editor-panel" id="editorPanel">
            <div class="file-tabs">
                <button class="tab active" data-file="main.py">main.py</button>
            </div>
            <div id="editor-container">
                <div id="editor" style="height:100%"></div>
            </div>
            <div class="prompt-panel">
                <input type="text" id="llmPromptInput" placeholder="Prompt für DeepSeek eingeben...">
                <button class="btn" id="sendToLlmBtn">An DeepSeek senden</button>
                <button class="btn" id="acceptLlmChangesBtn" style="display: none; margin-left: 10px;">Änderungen übernehmen</button>
                <button class="btn danger" id="rejectLlmChangesBtn" style="display: none; margin-left: 10px;">Ablehnen</button>
            </div>
        </div>

        <div id="resizerVertical"></div>

        <div class="terminal-panel" id="terminalPanel">
            <div class="terminal-header">
                <span>REPL Terminal</span>
                <button class="btn" id="clearTerminalBtn">Löschen</button>
            </div>
            <div class="terminal" id="terminal">Bereit für Verbindung...\n</div>
            <input class="terminal-input" id="terminalInput" placeholder=">>> MicroPython Befehl eingeben..." disabled>
        </div>
    </div>

    <!-- Modal für Dateinamen -->
    <div class="modal" id="filenameModal">
        <div class="modal-content">
            <h3>Datei speichern als:</h3>
            <input type="text" id="filenameInput" placeholder="dateiname.py">
            <div id="uploadProgressBarContainer" style="margin-top: 10px; background-color: #1e1e1e; border-radius: 4px; display: none;">
                <div id="uploadProgressBar" style="width: 0%; height: 10px; background-color: #0e639c; border-radius: 4px; text-align: center; line-height: 10px; font-size: 8px; color: white;"></div>
            </div>
            <div style="margin-top: 15px;">
                <button class="btn" id="saveFileBtn">Speichern</button>
                <button class="btn" onclick="closeModal()">Abbrechen</button>
            </div>
        </div>
    </div>

    <script>
        class MicroPythonIDE {
            constructor(editor) {
                this.port = null;
                this.reader = null;
                this.writer = null;
                this.isConnected = false;
                this.currentFile = 'main.py';
                this.editor = editor;
                this.files = {'main.py': this.editor.getValue()};
                this.deepSeekApiKey = localStorage.getItem('deepSeekApiKey') || '';
                this.diffEditor = null;
                this.diffEditorContainerDiv = null;
                this.originalEditorDiv = document.getElementById('editor');
                this.editorContainerDiv = document.getElementById('editor-container');
                this.totalSessionCostUnits = 0; // Für die Kostensummierung
                this.contextMenuTargetFile = null;
                this.deviceFiles = []; // Zum Speichern der aktuellen Dateiliste vom Gerät
                this.hardwareContext = ''; // Für den Inhalt von hardware.txt
                this.isLoadingHardwareContext = false; // Flag für das Laden von hardware.txt
                
                this.initializeEventListeners();
                this.checkWebSerialSupport();
                document.getElementById('deepSeekApiKeyInput').value = this.deepSeekApiKey;
            }

            checkWebSerialSupport() {
                if (!('serial' in navigator)) {
                    this.addToTerminal('❌ Web Serial API wird nicht unterstützt. Bitte verwende Chrome oder Edge.\n');
                }
            }

            initializeEventListeners() {
                document.getElementById('connectBtn').addEventListener('click', () => this.toggleConnection());
                document.getElementById('runBtn').addEventListener('click', () => this.runCode());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopExecution());
                document.getElementById('uploadBtn').addEventListener('click', () => this.showUploadModal());
                document.getElementById('listFilesBtn').addEventListener('click', () => this.listFiles());
                document.getElementById('softResetBtn').addEventListener('click', () => this.softReset());
                document.getElementById('clearTerminalBtn').addEventListener('click', () => this.clearTerminal());
                document.getElementById('terminalInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendCommand();
                });
                document.getElementById('saveFileBtn').addEventListener('click', () => this.uploadFile());
                document.getElementById('newFileBtn').addEventListener('click', () => this.newFile());

                // F5 für Ausführen
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'F5') {
                        e.preventDefault();
                        if (this.isConnected) this.runCode();
                    }
                });

                // Editor Änderungen speichern
                this.editor.onDidChangeModelContent(() => {
                    this.files[this.currentFile] = this.editor.getValue();
                });

                document.getElementById('deepSeekApiKeyInput').addEventListener('input', (e) => {
                    this.deepSeekApiKey = e.target.value;
                    localStorage.setItem('deepSeekApiKey', this.deepSeekApiKey);
                });

                document.getElementById('sendToLlmBtn').addEventListener('click', () => this.callDeepSeekApi());
                document.getElementById('acceptLlmChangesBtn').addEventListener('click', () => this.acceptLLMChanges());
                document.getElementById('rejectLlmChangesBtn').addEventListener('click', () => this.rejectLLMChanges());

                this.initializeResizer();
                this.initializeContextMenuListeners();
            }

            initializeContextMenuListeners() {
                const contextMenu = document.getElementById('fileContextMenu');
                document.addEventListener('click', (e) => { // Globaler Klick zum Schließen
                    if (!contextMenu.contains(e.target)) {
                        contextMenu.style.display = 'none';
                        this.contextMenuTargetFile = null;
                    }
                });

                contextMenu.querySelectorAll('.context-menu-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        const action = e.target.dataset.action;
                        if (this.contextMenuTargetFile) {
                            switch (action) {
                                case 'delete':
                                    this.promptDeleteFile(this.contextMenuTargetFile);
                                    break;
                                case 'rename':
                                    this.promptRenameFile(this.contextMenuTargetFile);
                                    break;
                            }
                        }
                        contextMenu.style.display = 'none';
                        this.contextMenuTargetFile = null;
                    });
                });
            }

            initializeResizer() {
                const resizer = document.getElementById('resizerVertical');
                const editorPanel = document.getElementById('editorPanel');
                const terminalPanel = document.getElementById('terminalPanel');
                const fileBrowser = document.querySelector('.file-browser');

                let initialX = 0;
                let initialTerminalWidth = 0;

                const onMouseMove = (e) => {
                    const dx = e.clientX - initialX;
                    let newTerminalWidth = initialTerminalWidth - dx;

                    const mainContentWidth = resizer.parentElement.offsetWidth;
                    const fileBrowserWidth = fileBrowser.offsetWidth;
                    const resizerWidth = resizer.offsetWidth;
                    
                    const minPanelPixelWidth = 150; // Mindestbreite für Editor und Terminal in Pixeln

                    const maxTerminalWidth = mainContentWidth - fileBrowserWidth - resizerWidth - minPanelPixelWidth;
                    
                    if (newTerminalWidth < minPanelPixelWidth) {
                        newTerminalWidth = minPanelPixelWidth;
                    }
                    if (newTerminalWidth > maxTerminalWidth) {
                        newTerminalWidth = maxTerminalWidth;
                    }
                    
                    const currentEditorWidth = mainContentWidth - fileBrowserWidth - resizerWidth - newTerminalWidth;
                    if (currentEditorWidth < minPanelPixelWidth) {
                        newTerminalWidth = mainContentWidth - fileBrowserWidth - resizerWidth - minPanelPixelWidth;
                        if (newTerminalWidth < minPanelPixelWidth) newTerminalWidth = minPanelPixelWidth; // Erneut prüfen
                    }

                    terminalPanel.style.flexBasis = `${newTerminalWidth}px`;

                    if (this.editor && typeof this.editor.layout === 'function') {
                        this.editor.layout();
                    }
                };

                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    document.body.style.cursor = 'default';
                    document.body.style.userSelect = 'auto';
                };

                resizer.addEventListener('mousedown', (e) => {
                    e.preventDefault(); // Verhindert Textauswahl während des Ziehens
                    initialX = e.clientX;
                    initialTerminalWidth = terminalPanel.offsetWidth;

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                    document.body.style.cursor = 'col-resize'; // Zeigt den Cursor global an
                    document.body.style.userSelect = 'none'; // Verhindert Textauswahl global
                });
            }

            async callDeepSeekApi() {
                const prompt = document.getElementById('llmPromptInput').value;
                const originalCode = this.editor.getValue(); // Originalcode speichern

                if (!this.deepSeekApiKey) {
                    this.addToTerminal('\n❌ Bitte zuerst einen DeepSeek API Key eingeben.\n');
                    console.error('DeepSeek API Key fehlt.');
                    alert('Bitte zuerst einen DeepSeek API Key im Feld oben rechts eingeben.');
                    return;
                }

                if (!prompt) {
                    this.addToTerminal('\nℹ️ Bitte einen Prompt für DeepSeek eingeben.\n');
                    alert('Bitte einen Prompt für DeepSeek eingeben.');
                    return;
                }

                this.addToTerminal('\n🤖 Sende Anfrage an DeepSeek...\n');
                const sendToLlmBtn = document.getElementById('sendToLlmBtn');
                sendToLlmBtn.disabled = true;
                sendToLlmBtn.innerHTML = '<span class="spinner"></span> Sende...';

                const API_URL = `https://api.deepseek.com/chat/completions`;
                const systemPrompt = "You are a helpful assistant that generates MicroPython code for microcontrollers. Ensure the code is valid MicroPython and directly usable on devices like ESP32. Only output the Python code, without any surrounding text or explanations unless explicitly asked.";
                
                let userPromptContent = `${prompt}\n\nAktueller Code im Editor (falls vorhanden, ansonsten generiere neuen Code):\n\`\`\`python\n${originalCode}\n\`\`\``;

                if (this.hardwareContext) {
                    userPromptContent = `Beachte die folgende Hardware-Konfiguration:\n<hardware_info>\n${this.hardwareContext}\n</hardware_info>\n\n${userPromptContent}`;
                    this.addToTerminal('\nℹ️ Hardware-Kontext wird an LLM gesendet.\n');
                }

                const requestBody = {
                    model: "deepseek-chat",
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: userPromptContent }
                    ],
                    temperature: 0.7,
                    // max_tokens: 2048, // Kann bei Bedarf angepasst werden
                };

                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.deepSeekApiKey}`
                        },
                        body: JSON.stringify(requestBody),
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error('DeepSeek API Error Response:', errorData);
                        this.addToTerminal(`\n❌ Fehler von DeepSeek API: ${response.status} ${response.statusText}\nDetails: ${JSON.stringify(errorData.error?.message || errorData)}\n`);
                        throw new Error(`API request failed with status ${response.status}: ${JSON.stringify(errorData)}`);
                    }

                    const data = await response.json();
                    console.log('DeepSeek API Success Response:', data);

                    // Nutzungsdaten und Kosten aktualisieren
                    if (data.usage) {
                        const usage = data.usage;
                        const promptTokens = usage.prompt_tokens || 0;
                        const completionTokens = usage.completion_tokens || 0;
                        const totalTokens = usage.total_tokens || 0;

                        // Preise für deepseek-chat (angenommen, bitte verifizieren):
                        // Input: 1 RMB / 1M tokens => 0.000001 RMB / token
                        // Output: 2 RMB / 1M tokens => 0.000002 RMB / token
                        // Wir verwenden "Mikro-Einheiten" (µ) zur Darstellung, wobei 1µ ~ 1 RMB / 1M Input Tokens
                        const costPerMillionInputTokens = 1; 
                        const costPerMillionOutputTokens = 2;

                        const currentCost = (promptTokens / 1000000) * costPerMillionInputTokens + 
                                          (completionTokens / 1000000) * costPerMillionOutputTokens;
                        
                        this.totalSessionCostUnits += currentCost;

                        document.getElementById('promptTokens').textContent = promptTokens;
                        document.getElementById('completionTokens').textContent = completionTokens;
                        document.getElementById('totalTokens').textContent = totalTokens;
                        document.getElementById('lastCost').textContent = currentCost.toFixed(6); // Zeigt z.B. 0.000123 an
                        document.getElementById('totalSessionCost').textContent = this.totalSessionCostUnits.toFixed(6);
                    } else {
                        // Reset, falls keine Nutzungsdaten vorhanden sind
                        document.getElementById('promptTokens').textContent = 'N/A';
                        document.getElementById('completionTokens').textContent = 'N/A';
                        document.getElementById('totalTokens').textContent = 'N/A';
                        document.getElementById('lastCost').textContent = 'N/A';
                    }

                    if (data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
                        let llmOutput = data.choices[0].message.content;
                        
                        // Versuche, reinen Code aus Markdown-Codeblöcken zu extrahieren
                        const codeBlockMatch = llmOutput.match(/```python\n([\s\S]*?)\n```|```([\s\S]*?)\n```/);
                        let newCode = llmOutput; 

                        if (codeBlockMatch) {
                            newCode = codeBlockMatch[1] || codeBlockMatch[2]; 
                            const textBefore = llmOutput.substring(0, codeBlockMatch.index).trim();
                            const textAfter = llmOutput.substring(codeBlockMatch.index + codeBlockMatch[0].length).trim();
                            if (textBefore) console.log("LLM Info (vor Codeblock):", textBefore);
                            if (textAfter) console.log("LLM Info (nach Codeblock):", textAfter);
                        } else {
                             // Wenn kein expliziter Codeblock, aber die Ausgabe mit "python" beginnt (manchmal bei DeepSeek)
                             if (llmOutput.toLowerCase().startsWith("python\n")) {
                                 newCode = llmOutput.substring("python\n".length);
                             }
                             console.log("LLM Info (kein expliziter Python-Codeblock gefunden, verwende angepasste/gesamte Ausgabe als Code):", llmOutput);
                        }
                        
                        // Entferne mögliche einleitende/abschließende Leerzeilen, die vom LLM kommen könnten
                        newCode = newCode.trim();

                        // Diff-Ansicht anzeigen, anstatt den Editor direkt zu aktualisieren
                        this.showDiff(originalCode, newCode);
                        this.addToTerminal('\n✅ Code vom LLM erhalten. Bitte überprüfen Sie die Änderungen.\n');
                        // document.getElementById('llmPromptInput').value = ''; // Wird jetzt in hideDiffAndRestoreEditor gemacht
                    } else {
                        console.warn('DeepSeek API: Keine gültigen Kandidaten in der Antwort gefunden.', data);
                        this.addToTerminal('\n⚠️ DeepSeek hat keinen Code oder eine unerwartete Antwortstruktur zurückgegeben.\n');
                    }

                } catch (error) {
                    console.error('Fehler bei der Anfrage an DeepSeek API:', error);
                    this.addToTerminal(`\n❌ Fehler bei der Kommunikation mit DeepSeek: ${error.message}\n`);
                } finally {
                    sendToLlmBtn.disabled = false;
                    sendToLlmBtn.innerHTML = 'An DeepSeek senden';
                }
            }

            showDiff(originalCode, newCode) {
                this.originalEditorDiv.style.display = 'none'; // Haupteditor ausblenden

                // Vorherigen Diff-Editor entfernen, falls vorhanden
                if (this.diffEditorContainerDiv) {
                    this.diffEditorContainerDiv.remove();
                }
                if (this.diffEditor) {
                    this.diffEditor.dispose(); // Wichtig: Monaco Editor Instanzen disposen
                    this.diffEditor = null;
                }

                this.diffEditorContainerDiv = document.createElement('div');
                this.diffEditorContainerDiv.style.width = '100%';
                this.diffEditorContainerDiv.style.height = '100%'; // Nimmt die volle Höhe des Parents
                this.editorContainerDiv.appendChild(this.diffEditorContainerDiv);

                this.diffEditor = monaco.editor.createDiffEditor(this.diffEditorContainerDiv, {
                    theme: 'vs-dark',
                    automaticLayout: true,
                    readOnly: false, // Erlaube Bearbeitung in der "modified" Seite, falls gewünscht
                    originalEditable: false, // Original sollte nicht bearbeitbar sein
                    renderSideBySide: true // Standard ist nebeneinander
                });

                const originalModel = monaco.editor.createModel(originalCode, 'python');
                const modifiedModel = monaco.editor.createModel(newCode, 'python');

                this.diffEditor.setModel({
                    original: originalModel,
                    modified: modifiedModel
                });

                // Buttons im Prompt-Panel umschalten
                document.getElementById('llmPromptInput').style.display = 'none';
                document.getElementById('sendToLlmBtn').style.display = 'none';
                document.getElementById('acceptLlmChangesBtn').style.display = 'inline-block';
                document.getElementById('rejectLlmChangesBtn').style.display = 'inline-block';
            }

            hideDiffAndRestoreEditor() {
                if (this.diffEditor) {
                    // Modelle explizit disposen, bevor der Editor disposed wird
                    const model = this.diffEditor.getModel();
                    if (model && model.original) model.original.dispose();
                    if (model && model.modified) model.modified.dispose();
                    this.diffEditor.dispose();
                    this.diffEditor = null;
                }
                if (this.diffEditorContainerDiv) {
                    this.diffEditorContainerDiv.remove();
                    this.diffEditorContainerDiv = null;
                }
                this.originalEditorDiv.style.display = 'block';
                this.editor.layout(); // Haupteditor neu zeichnen lassen

                // Buttons im Prompt-Panel zurücksetzen
                document.getElementById('llmPromptInput').style.display = 'block'; // Zurück zu block oder initial
                document.getElementById('llmPromptInput').style.flexGrow = '1'; // explizit wiederherstellen
                document.getElementById('sendToLlmBtn').style.display = 'inline-block';
                document.getElementById('sendToLlmBtn').disabled = false; // Sicherstellen, dass der Senden-Button wieder aktiv ist
                document.getElementById('acceptLlmChangesBtn').style.display = 'none';
                document.getElementById('rejectLlmChangesBtn').style.display = 'none';
                document.getElementById('llmPromptInput').value = ''; // Prompt-Feld leeren
            }

            acceptLLMChanges() {
                if (!this.diffEditor) return;
                const acceptedCode = this.diffEditor.getModel().modified.getValue();
                this.editor.setValue(acceptedCode);
                this.files[this.currentFile] = acceptedCode;
                this.addToTerminal('\n✅ LLM-Änderungen übernommen.\n');
                this.hideDiffAndRestoreEditor();
            }

            rejectLLMChanges() {
                if (!this.diffEditor) return; // Sollte nicht passieren, aber sicher ist sicher
                this.addToTerminal('\n❌ LLM-Änderungen abgelehnt.\n');
                this.hideDiffAndRestoreEditor();
            }

            updateActiveTab(filename) {
                const activeTab = document.querySelector('.file-tabs .tab.active');
                if (activeTab) {
                    activeTab.textContent = filename;
                    activeTab.dataset.file = filename;
                }
            }

            newFile() {
                if (this.diffEditor) { // Wenn in Diff-Ansicht, zuerst Änderungen verwerfen
                    this.rejectLLMChanges(); 
                }
                this.editor.setValue('');
                this.currentFile = 'untitled.py'; // Standardmäßig .py
                this.files[this.currentFile] = '';
                this.updateActiveTab(this.currentFile);
                // Upload-Button aktivieren, wenn verbunden, da jetzt eine (leere) Datei zum Speichern vorhanden ist
                document.getElementById('uploadBtn').disabled = !this.isConnected;
                this.addToTerminal(`\n✨ Neue Datei '${this.currentFile}' im Editor erstellt.\n`);
            }

            async fetchHardwareContextFile() {
                if (!this.isConnected) return;
                this.addToTerminal('\nℹ️ Versuche Hardware-Kontext (hardware.txt) zu laden...\n');
                this.isLoadingHardwareContext = true;
                this.hardwareContext = ''; // Alten Kontext löschen

                this.addToTerminal('🛑 Stoppe evtl. laufende Skripte (vor Hardware-Kontext-Laden)...\n');
                await this.sendRawCommand('\x03'); // Ctrl+C
                await new Promise(resolve => setTimeout(resolve, 50));
                await this.sendRawCommand('\r');   // Enter, um die REPL-Zeile zu säubern
                await new Promise(resolve => setTimeout(resolve, 50));

                const loadHardwareCode = `
try:
    with open('hardware.txt', 'r') as f_hw:
        print('===HARDWARE_CONTEXT_START===')
        print(f_hw.read())
        print('===HARDWARE_CONTEXT_END===')
except Exception as e_hw:
    print('===HARDWARE_CONTEXT_START===') # Sende Marker, damit isLoadingHardwareContext zurückgesetzt wird
    print(f"Fehler beim Lesen von hardware.txt: {e_hw}")
    print('===HARDWARE_CONTEXT_END===')
`;
                await this.sendRawCommand('\x05'); // Paste-Modus
                await new Promise(resolve => setTimeout(resolve, 50));
                await this.sendRawCommand(loadHardwareCode.replace(/\n/g, '\r') + '\r');
                await this.sendRawCommand('\x04'); // Ausführen
                await new Promise(resolve => setTimeout(resolve, 50)); // Kurze Pause
                await this.sendRawCommand('\r'); // REPL-Zeile säubern
                // Das Ergebnis wird in startReading() verarbeitet
            }

            async _executeDeviceCommand(command, successMessage, errorMessagePrefix) {
                if (!this.isConnected) return;

                this.addToTerminal('🛑 Stoppe evtl. laufende Skripte (vor Gerätebefehl)...\n');
                await this.sendRawCommand('\x03'); // Ctrl+C
                await new Promise(resolve => setTimeout(resolve, 50));
                await this.sendRawCommand('\r');   // Enter, um die REPL-Zeile zu säubern
                await new Promise(resolve => setTimeout(resolve, 50));

                this.addToTerminal(`\n⚙️ Führe aus: ${command.splitlines ? command.splitlines()[0] : command}\n`); // Zeige nur die erste Zeile bei mehrzeiligen Befehlen
                
                const script = `
try:
    import os
    ${command}
    print("===CMD_SUCCESS===")
except Exception as e:
    print(f"===CMD_ERROR===:{e}")
`;
                await this.sendRawCommand('\x05'); // Paste-Modus starten
                await new Promise(resolve => setTimeout(resolve, 50));
                await this.sendRawCommand(script.replace(/\n/g, '\r') + '\r');
                await this.sendRawCommand('\x04'); // Paste-Modus beenden und ausführen
                await new Promise(resolve => setTimeout(resolve, 50)); // Kurze Pause
                await this.sendRawCommand('\r'); // REPL-Zeile säubern
                await new Promise(resolve => setTimeout(resolve, 150)); // Restliche Wartezeit, falls für Befehlsausführung benötigt

                // Hier könnte man auf ===CMD_SUCCESS=== oder ===CMD_ERROR=== in der Terminalausgabe lauschen,
                // aber für den Moment verlassen wir uns auf die Terminalausgabe und aktualisieren die Dateiliste.
                // Eine robustere Lösung würde eine Callback-Mechanik oder Promises verwenden, die auf die Marker warten.
                if (successMessage) this.addToTerminal(`\n✅ ${successMessage}\n`);
                this.listFiles(); // Dateiliste immer aktualisieren
            }

            promptDeleteFile(filename) {
                if (confirm(`Möchten Sie die Datei '${filename}' wirklich löschen?`)) {
                    this._executeDeviceCommand(`os.remove('${filename}')`, `Datei '${filename}' gelöscht.`);
                }
            }

            promptRenameFile(oldFilename) {
                const newFilename = prompt(`Neuen Namen für '${oldFilename}' eingeben:`, oldFilename);
                if (newFilename && newFilename !== oldFilename) {
                    if (!newFilename.endsWith('.py') && !newFilename.endsWith('.txt')) {
                         alert('Dateiname muss mit .py oder .txt enden.');
                         return;
                    }
                    this._executeDeviceCommand(`os.rename('${oldFilename}', '${newFilename}')`, `Datei '${oldFilename}' umbenannt in '${newFilename}'.`);
                    if (this.currentFile === oldFilename) {
                        this.currentFile = newFilename;
                        this.updateActiveTab(newFilename);
                    }
                }
            }

            async toggleConnection() {
                if (this.isConnected) {
                    await this.disconnect();
                } else {
                    await this.connect();
                }
            }

            async connect() {
                try {
                    this.addToTerminal('🔌 Verbinde mit ESP32...\n');
                    
                    this.port = await navigator.serial.requestPort();
                    await this.port.open({ baudRate: 115200 });

                    this.reader = this.port.readable.getReader();
                    this.writer = this.port.writable.getWriter();

                    this.isConnected = true;
                    this.updateUI();
                    
                    this.addToTerminal('✅ Erfolgreich verbunden!\n');
                    
                    // Stoppe evtl. laufende Skripte und stelle sicher, dass die REPL bereit ist
                    this.addToTerminal('🛑 Stoppe evtl. laufende Skripte (nach Verbindung)...\n');
                    await this.sendRawCommand('\x03'); // Ctrl+C (Stop)
                    await new Promise(resolve => setTimeout(resolve, 50));
                    await this.sendRawCommand('\r');   // Enter, um die REPL-Zeile zu säubern
                    await new Promise(resolve => setTimeout(resolve, 50));
                                        
                    this.startReading();
                    
                } catch (error) {
                    this.addToTerminal(`❌ Verbindungsfehler: ${error.message}\n`);
                }
            }

            async disconnect() {
                try {
                    if (this.reader) {
                        await this.reader.cancel();
                        this.reader.releaseLock();
                    }
                    if (this.writer) {
                        this.writer.releaseLock();
                    }
                    if (this.port) {
                        await this.port.close();
                    }
                    
                    this.isConnected = false;
                    this.updateUI();
                    this.addToTerminal('🔌 Verbindung getrennt\n');
                    
                } catch (error) {
                    this.addToTerminal(`❌ Fehler beim Trennen: ${error.message}\n`);
                }
            }

            async startReading() {
                try {
                    let buffer = '';
                    while (this.isConnected) {
                        const { value, done } = await this.reader.read();
                        if (done) break;
                        
                        const text = new TextDecoder().decode(value);
                        this.addToTerminal(text);
                        
                        // Check for file list output
                        buffer += text;
                        if (buffer.includes('===FILELIST_END===')) {
                            const files = this.parseFileList(buffer);
                            if (files) {
                                this.updateFileBrowser(files);
                            }
                            buffer = '';
                        }
                        
                        // Check for file content output for editor
                        if (buffer.includes('===FILE_CONTENT_END===')) {
                            if (!this.isLoadingHardwareContext) { // Nur verarbeiten, wenn nicht Hardware-Kontext geladen wird
                                const content = this.parseFileContent(buffer);
                                if (content) {
                                    this.editor.setValue(content);
                                    this.files[this.currentFile] = content;
                                }
                            }
                            buffer = ''; // Buffer immer leeren, wenn End-Marker gefunden
                        }

                        // Check for hardware.txt content
                        if (buffer.includes('===HARDWARE_CONTEXT_END===')) {
                            if (this.isLoadingHardwareContext) {
                                const contextContent = this.parseHardwareContext(buffer);
                                if (contextContent !== null) {
                                    this.hardwareContext = contextContent;
                                    this.addToTerminal('\n✅ Hardware-Kontext (hardware.txt) geladen.\n');
                                } else {
                                    this.addToTerminal('\n⚠️ Hardware-Kontext (hardware.txt) konnte nicht vollständig gelesen werden.\n');
                                }
                                this.isLoadingHardwareContext = false;
                            }
                            buffer = ''; // Buffer immer leeren
                        }
                    }
                } catch (error) {
                    if (this.isConnected) {
                        this.addToTerminal(`❌ Lesefehler: ${error.message}\n`);
                    }
                }
            }

            async sendRawCommand(command) {
                if (!this.writer) return;
                
                const encoder = new TextEncoder();
                await this.writer.write(encoder.encode(command));
            }

            async sendCommand() {
                const input = document.getElementById('terminalInput');
                const command = input.value;
                
                if (!command.trim()) return;
                
                this.addToTerminal(`>>> ${command}\n`);
                await this.sendRawCommand(command + '\r\n');
                
                input.value = '';
            }

            async runCode() {
                if (!this.isConnected) return;
                
                if (!this.currentFile) {
                    this.addToTerminal('\n❌ Bitte erst eine Datei hochladen\n');
                    return;
                }
                
                this.addToTerminal(`\n=== Führe ${this.currentFile} aus ===\n`);

                this.addToTerminal('🛑 Stoppe evtl. laufende Skripte (vor Code-Ausführung)...\n');
                await this.sendRawCommand('\x03'); // Ctrl+C
                await new Promise(resolve => setTimeout(resolve, 50));
                await this.sendRawCommand('\r');   // Enter, um die REPL-Zeile zu säubern
                await new Promise(resolve => setTimeout(resolve, 50));
                
                // Code ausführen mittels Paste-Modus und exec
                // await this.sendRawCommand('\r\n'); // Nicht mehr nötig, da \r oben gesendet wurde

                // Construct the script with \r line endings for paste mode

                const pythonScriptSource = `try:
    with open('${this.currentFile}', 'r') as f:
        exec(f.read())
except OSError:
    print("Error: ${this.currentFile} not found")
except SyntaxError as e:
    print(f"SyntaxError in ${this.currentFile}: {e}")
`;
                const pythonScript = pythonScriptSource.replace(/\n/g, '\r') + '\r';                

                await this.sendRawCommand('\x05'); // Ctrl-E: Paste-Modus starten
                await new Promise(resolve => setTimeout(resolve, 100)); // Kurze Pause
                
                await this.sendRawCommand(pythonScript); // pythonScript hat bereits \r Endungen
                // Keine zusätzliche Pause hier, da der gesamte Block auf einmal gesendet wird
                
                await this.sendRawCommand('\x04'); // Ctrl-D: Paste-Modus beenden und ausführen
                await new Promise(resolve => setTimeout(resolve, 50)); // Kurze Pause danach
                await this.sendRawCommand('\r'); // REPL-Zeile säubern
                await new Promise(resolve => setTimeout(resolve, 50)); 
            }

            async stopExecution() {
                if (!this.isConnected) return;
                
                this.addToTerminal('\n🛑 Stoppe Ausführung...\n');
                await this.sendRawCommand('\x03'); // Ctrl+C
            }

            async softReset() {
                if (!this.isConnected) return;
                
                this.addToTerminal('\n🔄 Soft Reset...\n');
                await this.sendRawCommand('\x04'); // Ctrl+D
            }

            showUploadModal() {
                document.getElementById('filenameModal').style.display = 'block';
                document.getElementById('filenameInput').value = this.currentFile;
                document.getElementById('filenameInput').focus();
                // Fortschrittsbalken zurücksetzen und ausblenden
                const progressBarContainer = document.getElementById('uploadProgressBarContainer');
                const progressBar = document.getElementById('uploadProgressBar');
                progressBar.style.width = '0%';
                progressBar.textContent = '';
                progressBarContainer.style.display = 'none';
            }

            async uploadFile() {
                const filename = document.getElementById('filenameInput').value;
                if (!filename) return;
                if (!filename.endsWith('.py') && !filename.endsWith('.txt')) {
                    this.addToTerminal('\n❌ Dateiname muss mit .py oder .txt enden\n');
                    return;
                }
                
                const code = this.editor.getValue();
                this.currentFile = filename;
                this.updateActiveTab(filename); // Tab aktualisieren
                const chunkSize = 200; // Noch kleinere Chunk-Größe
                const totalChunks = Math.ceil(code.length / chunkSize);

                const progressBarContainer = document.getElementById('uploadProgressBarContainer');
                const progressBar = document.getElementById('uploadProgressBar');
                progressBar.style.width = '0%';
                progressBar.textContent = '0%';
                progressBarContainer.style.display = 'block';
                
                this.addToTerminal(`\n📤 Lade ${filename} hoch (${code.length} Zeichen, ${totalChunks} Teile)...\n`);
                this.addToTerminal('⚠️ Bitte warten während die Datei hochgeladen wird...\n');
                
                try {
                    // Datei erstellen
                    await this.sendRawCommand('\x05');
                    await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                    await this.sendRawCommand(`f=open('${filename}','w')\r\n`);
                    await this.sendRawCommand('\x04');
                    await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                    
                    // Code in Chunks hochladen
                    for (let i = 0; i < totalChunks; i++) {
                        const chunk = code.substring(i * chunkSize, (i + 1) * chunkSize);
                        // Sonderzeichen escapen
                        const escapedChunk = chunk
                            .replace(/\\/g, '\\\\')
                            .replace(/'/g, "\\'")
                            .replace(/\r/g, '\\r')
                            .replace(/\n/g, '\\n');
                        
                        try {
                            await this.sendRawCommand('\x05');
                            await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                            await this.sendRawCommand(`f.write('${escapedChunk}')\r\n`);
                            await this.sendRawCommand('\x04');
                            await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                            
                            // Fortschritt anzeigen
                            const progress = Math.round(((i + 1) / totalChunks) * 100);
                            this.addToTerminal(`\r🔼 Hochgeladen: ${progress}% (${(i + 1) * chunkSize}/${code.length})`);
                            progressBar.style.width = progress + '%';
                            progressBar.textContent = progress + '%';
                        } catch (error) {
                            this.addToTerminal(`\n❌ Fehler bei Chunk ${i+1}: ${error.message}\n`);
                            progressBarContainer.style.display = 'none'; // Fortschrittsbalken bei Fehler ausblenden
                            throw error;
                        }
                    }
                    
                    // Datei schließen
                    await this.sendRawCommand('\x05');
                    await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                    await this.sendRawCommand('f.close()\r\n');
                    await this.sendRawCommand('\x04');
                    await new Promise(resolve => setTimeout(resolve, 100)); // Reduziert von 200ms
                    
                    this.addToTerminal(`\n✅ ${filename} erfolgreich hochgeladen!\n`);
                    progressBar.textContent = '100%'; // Sicherstellen, dass es 100% anzeigt
                    
                } catch (error) {
                    this.addToTerminal(`\n❌ Fehler beim Hochladen: ${error.message}\n`);
                    progressBarContainer.style.display = 'none'; // Fortschrittsbalken bei Fehler ausblenden
                } finally {
                    // Kurze Verzögerung, bevor das Modal geschlossen wird, damit der Benutzer 100% sieht
                    setTimeout(() => {
                        closeModal();
                        // Fortschrittsbalken für das nächste Mal ausblenden (wird auch in showUploadModal gemacht, aber sicher ist sicher)
                        progressBarContainer.style.display = 'none';
                        progressBar.style.width = '0%';
                        progressBar.textContent = '';
                    }, 500);
                    setTimeout(() => this.listFiles(), 1000); // listFiles nach dem Schließen des Modals
                }
            }

            async loadFile(filename) {
                if (!this.isConnected) return;

                this.addToTerminal('🛑 Stoppe evtl. laufende Skripte (vor Datei-Laden)...\n');
                await this.sendRawCommand('\x03'); // Ctrl+C
                await new Promise(resolve => setTimeout(resolve, 50));
                await this.sendRawCommand('\r');   // Enter, um die REPL-Zeile zu säubern
                await new Promise(resolve => setTimeout(resolve, 50));
                
                this.addToTerminal(`\n📥 Lade ${filename}...\n`);
                
                const loadCode = `
try:
    with open('${filename}', 'r') as f:
        print('===FILE_CONTENT_START===')
        print(f.read())
        print('===FILE_CONTENT_END===')
except Exception as e:
    print('Fehler:', e)
`;
                
                await this.sendRawCommand('\x05');
                await new Promise(resolve => setTimeout(resolve, 100));
                await this.sendRawCommand(loadCode.replace(/\n/g, '\r') + '\r'); // Korrektur und korrekte Zeilenenden
                await this.sendRawCommand('\x04');
                await new Promise(resolve => setTimeout(resolve, 50)); // Kurze Pause
                await this.sendRawCommand('\r'); // REPL-Zeile säubern
                
                // Datei im Editor anzeigen
                this.currentFile = filename;
                this.updateActiveTab(filename); // Tab aktualisieren
                this.editor.setValue(''); // Inhalt wird durch Lesevorgang gefüllt
            }

            parseFileContent(text) {
                const startMarker = '===FILE_CONTENT_START===';
                const endMarker = '===FILE_CONTENT_END===';
                
                const start = text.indexOf(startMarker);
                const end = text.indexOf(endMarker);
                
                if (start === -1 || end === -1) return null;
                
                let content = text.substring(start + startMarker.length, end);
                // Normalisiere Zeilenenden (CRLF -> LF)
                content = content.replace(/\r\n/g, '\n');
                // Entferne überflüssige Leerzeilen am Anfang und Ende
                content = content.replace(/^\n+|\n+$/g, '');
                return content;
            }

            parseHardwareContext(text) {
                const startMarker = '===HARDWARE_CONTEXT_START===';
                const endMarker = '===HARDWARE_CONTEXT_END===';
                
                const start = text.indexOf(startMarker);
                const end = text.indexOf(endMarker);
                
                if (start === -1 || end === -1) return null; // Nicht vollständig
                
                let content = text.substring(start + startMarker.length, end);
                content = content.replace(/\r\n/g, '\n').trim(); // Normalisieren und trimmen
                
                // Prüfen, ob ein Fehler beim Lesen gemeldet wurde
                if (content.startsWith("Fehler beim Lesen von hardware.txt:")) {
                    this.addToTerminal(`\n⚠️ ${content}\n`); // Fehler im Terminal anzeigen
                    return ''; // Leeren Kontext zurückgeben, da Datei nicht lesbar war
                }
                return content;
            }

            async listFiles() {
                if (!this.isConnected) return;

                this.addToTerminal('🛑 Stoppe evtl. laufende Skripte (vor Dateiliste)...\n');
                await this.sendRawCommand('\x03'); // Ctrl+C
                await new Promise(resolve => setTimeout(resolve, 50));
                await this.sendRawCommand('\r');   // Enter, um die REPL-Zeile zu säubern
                await new Promise(resolve => setTimeout(resolve, 50));
                
                this.addToTerminal('\n📁 Dateien werden aufgelistet...\n');
                
                const listCode = `
import os
print('===FILELIST_START===')
for file in os.listdir():
    try:
        stat = os.stat(file)
        size = stat[6]
        print(f'{file}|{size}')
    except:
        print(f'{file}|folder')
print('===FILELIST_END===')
`;
                
                await this.sendRawCommand('\x05');
                await new Promise(resolve => setTimeout(resolve, 100));
                await this.sendRawCommand(listCode.replace(/\n/g, '\r') + '\r'); // Korrekte Zeilenenden für Paste-Modus
                await this.sendRawCommand('\x04');
                await new Promise(resolve => setTimeout(resolve, 50)); // Kurze Pause
                await this.sendRawCommand('\r'); // REPL-Zeile säubern
            }

            parseFileList(text) {
                const startMarker = '===FILELIST_START===';
                const endMarker = '===FILELIST_END===';
                
                const start = text.indexOf(startMarker);
                const end = text.indexOf(endMarker);
                
                if (start === -1 || end === -1) return null;
                
                const fileListText = text.substring(start + startMarker.length, end).trim();
                const lines = fileListText.split('\n');
                
                const files = [];
                for (const line of lines) {
                    const [name, size] = line.split('|');
                    files.push({name, size});
                }
                
                return files;
            }

            updateFileBrowser(files) {
                this.deviceFiles = files.map(f => f.name); // Aktuelle Dateinamen speichern
                
                // Prüfen, ob hardware.txt vorhanden ist und eine Datei ist, dann laden/aktualisieren
                const hardwareTxtEntry = files.find(f => f.name === 'hardware.txt');
                if (hardwareTxtEntry && hardwareTxtEntry.size !== 'folder') {
                    this.fetchHardwareContextFile();
                } else {
                    if (this.hardwareContext) { // hardware.txt nicht (als Datei) gefunden, Kontext löschen
                        this.hardwareContext = '';
                        if (hardwareTxtEntry && hardwareTxtEntry.size === 'folder') {
                            this.addToTerminal('\nℹ️ Hardware-Kontext (hardware.txt) ist ein Ordner und wird nicht geladen.\n');
                        } else {
                            this.addToTerminal('\nℹ️ Hardware-Kontext (hardware.txt) nicht als Datei gefunden oder entfernt.\n');
                        }
                    }
                }

                const fileListElement = document.getElementById('fileList');
                const contextMenu = document.getElementById('fileContextMenu');
                fileListElement.innerHTML = '';
                
                files.forEach(file => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.textContent = `${file.name} (${file.size === 'folder' ? 'Ordner' : file.size + ' bytes'})`;
                    
                    fileItem.addEventListener('click', () => {
                        contextMenu.style.display = 'none'; // Kontextmenü ausblenden, falls offen
                        this.loadFile(file.name);
                    });

                    fileItem.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        this.contextMenuTargetFile = file.name;
                        contextMenu.style.left = `${e.clientX}px`;
                        contextMenu.style.top = `${e.clientY}px`;
                        contextMenu.style.display = 'block';
                    });
                    fileListElement.appendChild(fileItem);
                });
            }

            addToTerminal(text) {
                const terminal = document.getElementById('terminal');
                terminal.textContent += text;
                terminal.scrollTop = terminal.scrollHeight;
            }

            clearTerminal() {
                document.getElementById('terminal').textContent = '';
            }

            updateUI() {
                const connectBtn = document.getElementById('connectBtn');
                const status = document.getElementById('status');
                // 'newFileBtn' wird hier nicht mehr aufgeführt, da er immer aktiv sein soll.
                // 'uploadBtn' wird separat behandelt (z.B. in newFile oder wenn eine Datei geladen wird).
                const buttonsToToggle = ['runBtn', 'stopBtn', 'listFilesBtn', 'softResetBtn'];
                const terminalInput = document.getElementById('terminalInput');
                
                if (this.isConnected) {
                    connectBtn.textContent = 'Trennen';
                    status.textContent = 'Verbunden';
                    status.className = 'status connected';
                    buttonsToToggle.forEach(id => document.getElementById(id).disabled = false);
                    document.getElementById('uploadBtn').disabled = false; // Generell Upload erlauben wenn verbunden
                    terminalInput.disabled = false;
                } else {
                    connectBtn.textContent = 'Mit ESP32 verbinden';
                    status.textContent = 'Nicht verbunden';
                    status.className = 'status disconnected';
                    buttonsToToggle.forEach(id => document.getElementById(id).disabled = true);
                    document.getElementById('uploadBtn').disabled = true; // Upload nur wenn verbunden
                    terminalInput.disabled = true;
                }
            }
        }

        function closeModal() {
            document.getElementById('filenameModal').style.display = 'none';
        }

        // Monaco Editor initialisieren
        function initEditor() {
            try {
                require(['vs/editor/editor.main'], function() {
                    const editor = monaco.editor.create(document.getElementById('editor'), {
                        value: [
                            "# Dein MicroPython Code hier...",
                            "print('Hello ESP32!')",
                            "",
                            "# Beispiel: LED blinken",
                            "from machine import Pin",
                            "import time",
                            "",
                            "led = Pin(2, Pin.OUT)  # GPIO 2 für eingebaute LED",
                            "",
                            "for i in range(10):",
                            "    led.on()",
                            "    time.sleep(0.5)",
                            "    led.off()",
                            "    time.sleep(0.5)",
                            "    print('Blink ' + str(i + 1))  # f-string removed for wider compatibility"
                        ].join('\n'),
                        language: 'python',
                        theme: 'vs-dark',
                        automaticLayout: true,
                        minimap: { enabled: false },
                        fontSize: 14,
                        lineNumbers: 'on',
                        roundedSelection: true,
                        scrollBeyondLastLine: false,
                        renderWhitespace: 'selection',
                        tabSize: 4
                    });

                    // IDE initialisieren und Editor übergeben
                    window.ide = new MicroPythonIDE(editor);
                });
            } catch (error) {
                console.error('Editor Initialization Error:', error);
                // Fallback falls Monaco nicht lädt
                const editorElement = document.getElementById('editor');
                editorElement.innerHTML = '<textarea style="width:100%;height:100%;background:#1e1e1e;color:#d4d4d4;border:none;padding:10px;font-family:monospace;font-size:14px;" id="fallbackEditor"># Dein MicroPython Code hier...\nprint(\'Hello ESP32!\')</textarea>';
                window.ide = new MicroPythonIDE({
                    getValue: () => document.getElementById('fallbackEditor').value,
                    setValue: (content) => document.getElementById('fallbackEditor').value = content,
                    onDidChangeModelContent: (callback) => {
                        document.getElementById('fallbackEditor').addEventListener('input', callback);
                    }
                });
            }
        }

        // Editor laden wenn alles fertig ist
        if (document.readyState === 'complete') {
            initEditor();
        } else {
            window.addEventListener('load', initEditor);
        }
    </script>

    <div id="fileContextMenu" class="context-menu" style="display: none; position: absolute; background-color: #3c3c3c; border: 1px solid #555; padding: 5px 0; z-index: 1001; border-radius: 4px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
        <div class="context-menu-item" data-action="rename">Umbenennen</div>
        <div class="context-menu-item" data-action="delete">Löschen</div>
    </div>
</body>
</html>
